<!DOCTYPE HTML>

<html>
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z0NSFPKNBN">
        </script>
        <script>
            window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Z0NSFPKNBN');
        </script>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Permissions-Policy" content="interest-cohort=()">
        <title>
            Modeling dataframes in Haskell using higher-kinded types - Laurent P. René de Cotret
        </title>
        <link rel="icon" type="image/x-icon" href="../images/atom-solid.png">
        <link rel="stylesheet" type="text/css" href="../css/syntax.css">
        <link rel="stylesheet" type="text/css" href="../css/style.css">
        <link rel="stylesheet" type="text/css" href="https://use.fontawesome.com/releases/v5.15.1/css/all.css">
        <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css">
        <link rel="stylesheet" type="font" href="https://fonts.googleapis.com/css?family=Titillium+Web">
        <script type="text/javascript" src="../js/navbar-onclick.js">
        </script>
    </head>
    <body>
        <section class="hero-with-background is-dark">
            <div class="hero-head">
                <nav class="navbar is-transparent">
                    <div class="container">
                        <div class="navbar-brand">
                            <a class="navbar-item has-text-light" href="../index.html">
                                <strong>
                                    Laurent P. René de Cotret
                                </strong>
                            </a>
                            <span class="navbar-burger burger has-text-light" id="burger" onclick="toggleBurger()">
                                <span>
                                </span>
                                <span>
                                </span>
                                <span>
                                </span>
                            </span>
                        </div>
                        <div class="navbar-menu" id="navbarMenu">
                            <div class="navbar-end">
                                <a class="navbar-item" href="../index.html">
                                    Home
                                </a>
                                <a class="navbar-item" href="../software.html">
                                    Software
                                </a>
                                <a class="navbar-item" href="../publications.html">
                                    Publications
                                </a>
                                <a class="navbar-item" href="../about.html">
                                    About me
                                </a>
                                <a class="navbar-item" href="../archive.html">
                                    All blog posts
                                </a>
                            </div>
                        </div>
                    </div>
                </nav>
            </div>
            <div class="hero-body">
                <div class="container has-text-centered">
                    <h1 class="title has-text-light">
                        Modeling dataframes in Haskell using higher-kinded types
                    </h1>
                    <h3>
                        
                        Posted on 2025-01-22. 
                        
                        
                        Last updated on 2025-02-08.
                        
                    </h3>
                    <h3>
                        
                        Estimated reading time of 14 min.
                        
                    </h3>
                    <h3>
                        
                        <span class="icon has-text-link">
                            <i class="fas fa-tag">
                            </i>
                        </span>
                         Tags: <a title="All pages tagged 'haskell'." href="../tags/haskell.html" rel="tag">haskell</a>, <a title="All pages tagged 'science'." href="../tags/science.html" rel="tag">science</a>
                        
                    </h3>
                </div>
            </div>
            <div class="hero-foot">
                <div class="navbar is-transparent">
                    <div class="container">
                        <div class="navbar-menu">
                            <div class="navbar-start">
                                <a class="navbar-item has-text-light" target="_blank" href="../email.html">
                                    <span class="icon is-medium">
                                        <i class="fas fa-envelope">
                                        </i>
                                    </span>
                                    e-mail
                                </a>
                                <a class="navbar-item has-text-light" target="_blank" href="https://github.com/LaurentRDC">
                                    <span class="icon is-medium">
                                        <i class="fab fa-github">
                                        </i>
                                    </span>
                                    GitHub
                                </a>
                                <a class="navbar-item has-text-light" target="_blank" href="https://www.linkedin.com/in/laurentrdc">
                                    <span class="icon is-medium">
                                        <i class="fab fa-linkedin">
                                        </i>
                                    </span>
                                    LinkedIn
                                </a>
                                <a class="navbar-item has-text-light" target="_blank" href="https://www.researchgate.net/profile/Laurent_Rene_De_Cotret">
                                    <span class="icon is-medium">
                                        <i class="ai ai-researchgate">
                                        </i>
                                    </span>
                                    ResearchGate
                                </a>
                                <a class="navbar-item has-text-light" target="_blank" href="https://orcid.org/0000-0002-1464-2739">
                                    <span class="icon is-medium">
                                        <i class="ai ai-orcid">
                                        </i>
                                    </span>
                                    OrcID
                                </a>
                                <a class="navbar-item has-text-light" target="_blank" href="https://scholar.google.ca/citations?user=pXFhwioAAAAJ&amp;hl=en">
                                    <span class="icon is-medium">
                                        <i class="ai ai-google-scholar">
                                        </i>
                                    </span>
                                    Google Scholar
                                </a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <div class="section">
            <div class="container">
                <div class="content">
                    <p><em>Featured in <a href="https://haskellweekly.news/issue/456.html">Haskell Weekly issue 456</a></em></p>
<p>I am a firm believer in the purely functional programming approach, embodied by the Haskell programming language. While the Haskell
community is not huge, it is large enough that I can work on most domains.</p>
<p>Most domains, but not all; data science remains hard to work on in Haskell. Since data science grew out not from software engineering,
but from students and scientists, the best data science tools are found in other communities such as <a href="https://www.r-project.org/">R</a> and
<a href="https://www.python.org/">Python</a>. If we focus further on machine-learning and “““AI”“” (ಠ_ಠ), then the distribution of high-quality
tools is even more concentrated in the Python community.</p>
<p>I have started exploring what it would look like to build a Haskell-centric data science workflow more than a year ago, with the
implementation of a <a href="https://hackage.haskell.org/package/javelin-0.1.4.1/docs/Data-Series-Tutorial.html">Series data structure</a>.
While this was perfect for my use-case at the time (I wrote about it <a href="../posts/rolling-stats.html">here</a>
and <a href="../posts/typesafe-tradingstrats.html">here</a>), the typical data scientist is used to columnar the data structure known as the
<em>dataframe</em>.</p>
<p>Recently, an effort to <a href="(https://discourse.haskell.org/t/design-dataframes-in-haskell/11108)">design a dataframe interface</a> in Haskell
has been spearheaded by Michael Chavinda, with a focus on exploratory data science. This effort trades type safety for easier
interactivity, similar to <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html">Python’s pandas DataFrames</a>.</p>
<p>In this blog post, I want to explore a different design tradeoff: what if one were to instead focus on type-safe expressiveness, with
no regards to interactivity? What would such a dataframe interface look like?</p>
<p>The design below is based on some intermediate type-level shenanigans. I was inspired by the approach that
the <a href="https://github.com/haskell-beam/beam">Beam SQL project</a> took, based on higher-kinded types.</p>
<p>Let’s get imports out of the way:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DefaultSignatures #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">HKTGenerics</span> <span class="kw">where</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- from `base`</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Identity</span> (<span class="dt">Identity</span>(..))</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Kind</span> (<span class="dt">Type</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- from `vector`</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span></span></code></pre></div>
<p>Let’s consider an example: we want to represent a set of people of some sort. We would normally represent
one person using a record type like so:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SimpleUser</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkSimpleUser</span> {<span class="ot"> simpleUserFirstName ::</span> <span class="dt">String</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                   ,<span class="ot"> simpleUserLastName  ::</span> <span class="dt">String</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                   ,<span class="ot"> simpleUserAge       ::</span> <span class="dt">Int</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                   }</span></code></pre></div>
<p>Now, a <em>dataframe</em> of such users should be equivalent to:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FrameUser</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkFrameUser</span> {<span class="ot"> frameUserFirstName ::</span> <span class="dt">Vector</span> <span class="dt">String</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                  ,<span class="ot"> frameUserLastName  ::</span> <span class="dt">Vector</span> <span class="dt">String</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                  ,<span class="ot"> frameUserAge       ::</span> <span class="dt">Vector</span> <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                  }</span></code></pre></div>
<p>where each record is a <code>Vector</code> (similar to arrays in other languages), representing a column. This is the main draw of dataframes:
data is stored in columns, rather than simply e.g. <code>Vector SimpleUser</code>. This is not always best, but I will assume that the user
has knowledge of the tradeoffs.</p>
<p>The structures of <code>SimpleUser</code> and <code>FrameUser</code> are extremely similar. We can use higher-kinded types to unify them by introducing a
type parameter <code>f</code> which represents the container for values:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HKTUser</span> f</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkHKTUser</span> {<span class="ot"> hktUserFirstName ::</span> f <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> hktUserLastName  ::</span> f <span class="dt">String</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> hktUserAge       ::</span> f <span class="dt">Int</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                }</span></code></pre></div>
<p>Here, <code>f</code> has type <code>f :: Type -&gt; Type</code>, just like the <code>Vector</code> type constructor. <code>HKTUser</code> is called a higher-kinded type, because
unlike a type like <code>SimpleUser</code>, which has kind <code>Type</code>, <code>HKTUser</code> isn’t a type, but a <em>type constructor</em>. I won’t go into more detail
than this on higher-kinded types; consider watching the <a href="https://www.youtube.com/live/EXgsXy1BR-0?si=9CMdb_wHJvCNfNYr">Haskell Unfolder episode on the subject</a>.</p>
<p>Using this method of representing users, we can represent <code>SimpleUser</code> as <code>HKTUser Identity</code>, and <code>FrameUser</code> as <code>HKTUser Vector</code>.
Here, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Functor-Identity.html"><code class="has-text-link">Identity</code></a> is the trivial container.</p>
<p>One more thing before we move on. While <code>Identity</code> is a trivial functor, it still adds some overhead; <code>HKTUser Identity</code> and <code>SimpleUser</code>
aren’t <em>exactly</em> equivalent. We can optimize this overhead away using a type family:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Column</span> (<span class="ot">f ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) x <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Column</span> <span class="dt">Identity</span> x <span class="ot">=</span> x <span class="co">-- Optimization</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Column</span> <span class="dt">Vector</span> x <span class="ot">=</span> <span class="dt">Vector</span> x</span></code></pre></div>
<p>Finally, we can unify the representations of <code>SimpleUser</code> and <code>FrameUser</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> f</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkUser</span> {<span class="ot"> userFirstName ::</span> <span class="dt">Column</span> f <span class="dt">String</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>             ,<span class="ot"> userLastName  ::</span> <span class="dt">Column</span> f <span class="dt">String</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>             ,<span class="ot"> userAge       ::</span> <span class="dt">Column</span> f <span class="dt">Int</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>             }</span></code></pre></div>
<p>The <code>Column</code> type family can be thought of a <em>type-level function</em>: <code>Column f a</code> is a type that depends on <code>f</code>. To be clearer, let’s
create type synonyms:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Row</span>   (<span class="ot">dt ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">=</span> dt <span class="dt">Identity</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Frame</span> (<span class="ot">dt ::</span> (<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">-&gt;</span> <span class="dt">Type</span>) <span class="ot">=</span> dt <span class="dt">Vector</span></span></code></pre></div>
<p>Using these synonyms, <code>Row User</code> is equivalent to <code>SimpleUser</code>. while <code>Frame User</code> is equivalent to <code>FrameUser</code>. We can operate on the
columns of dataframes easily, like so:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Returns the longest first name out of a dataframe of users.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- If the dataframe is empty, returns the empty string.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">longestFirstName ::</span> <span class="dt">Frame</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>longestFirstName <span class="ot">=</span> Data.Vector.foldl' longest <span class="fu">mempty</span> <span class="op">.</span> userFirstName</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">        longest ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        longest x y <span class="ot">=</span> <span class="kw">if</span> <span class="fu">length</span> x <span class="op">&gt;=</span> <span class="fu">length</span> y <span class="kw">then</span> x <span class="kw">else</span> y</span></code></pre></div>
<p>With <code>longestFirstName</code>, we can glimpse the performance advantage of using dataframes: the <code>userFirstName</code> field is really
an array, and so finding the longest first name is an operation on an array of string rather than an array of <code>User</code>.</p>
<p>How can we build a dataframe? We can turn rows of, well, <code>Row User</code> into a single <code>Frame User</code> like so:
<!-- 
    Using the markdown syntax below will prevent the Haskell compiler
    from looking at the code
--></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">buildUserFrame ::</span> <span class="dt">Vector</span> (<span class="dt">Row</span> <span class="dt">User</span>) <span class="ot">-&gt;</span> <span class="dt">Frame</span> <span class="dt">User</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>buildUserFrame vs </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkUser</span> { userFirstName <span class="ot">=</span> Data.Vector.map userFirstName vs</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>             , userLastName  <span class="ot">=</span> Data.Vector.map userLastName vs</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>             , userAge       <span class="ot">=</span> Data.Vector.map userAge vs</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>             }</span></code></pre></div>
<p>This is a little tedious; for every type of dataframe, we need to write our own dataframe construction function!
Can we write a function like <code class="sourceCode haskell"><span class="dt">Vector</span> (<span class="dt">Row</span> t) <span class="ot">-&gt;</span> <span class="dt">Frame</span> t</code>, which works for any <code>t</code>? Yes we can.</p>
<h2 class="title is-2" id="enter-generics">Enter generics</h2>
<p><em>I want to thank <strong>Li-yao Xia</strong> (Lysxia on the <a href="https://discourse.haskell.org/">Haskell Discourse</a>) for helping me
figure out how to do what you’re about to read!</em></p>
<p>If you squint, every type we would want to turn into a dataframe has the same structure: a record type where every record
is either <code>Vector a</code> or <code>Identity a</code> (nesting dataframes is out of scope for today). We can provide functionality for any
suitable record type like that using Haskell generics<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>In Haskell, the <code>Generic</code> typeclass has nothing to do with “generics” in other programming language. “Generic” programming in Haskell is done
with ad-hoc polymorphism (i.e. typeclasses). Instead, the <code>Generic</code> typeclass in Haskell is used to transform any datatype <code>t</code> into
a generic representation, called <code>Rep t</code>, which can be used define functions which work over a large class
of types. Specifically, in our case, we want to create a function <code class="sourceCode haskell"><span class="dt">Vector</span> (<span class="dt">Row</span> t) <span class="ot">-&gt;</span> <span class="dt">Frame</span> t</code> which works
for <strong>any higher-kinded record type</strong> <code>t</code> like <code>User</code>.</p>
<p>There are many explanations of Haskell’s <code>Generic</code>, such as <a href="https://markkarpov.com/tutorial/generics.html">Mark Karpov’s Generics explained</a>
blog post. The wrinkle in our dataframe problem is that types such as <code>User</code> are higher-kinded, and therefore some more care
is required.</p>
<p>Let’s define our problem. We want to create a typeclass <code>FromRows</code> with a method, <code>fromRows</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">FromRows</span> t <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fromRows ::</span> <span class="dt">Vector</span> (<span class="dt">Row</span> t) <span class="ot">-&gt;</span> <span class="dt">Frame</span> t</span></code></pre></div>
<p>We also want to provide a default definition of <code>fromRows</code> such that downstream users don’t have to manually write instances
of <code>FromRows</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    default<span class="ot"> fromRows ::</span> (<span class="op">???</span>) <span class="ot">=&gt;</span> <span class="dt">Vector</span> (<span class="dt">Row</span> t) <span class="ot">-&gt;</span> <span class="dt">Frame</span> t</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    fromRows <span class="ot">=</span> <span class="op">???</span></span></code></pre></div>
<p>How can we write the default implementation of <code>fromRows</code>?</p>
<p>The key concept to remember is that <code>Generic</code> only works with types of kind <code>Type</code>, i.e. <code>Row User</code> but not <code>User</code>. For every
higher-kinded type <code>t</code> (like <code>User</code>), we care about two concrete types: <code>Row t</code> and <code>Frame t</code>. Therefore, we need to index our
typeclass on both concrete types at once.</p>
<p>Enough word salad:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GFromRows</span> r <span class="co">-- intended to be `Row`-like</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                f <span class="co">-- intended to be `Frame`-like</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span>  </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    gfromRows ::</span> <span class="dt">Vector</span> (r a) <span class="ot">-&gt;</span> (f a)</span></code></pre></div>
<p>We need to provide instances relating to some (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#g:14">but not all</a>)
generic constructs, including <code>M1</code> (which is always required), <code>K1</code>, and <code>(:*:)</code>.</p>
<p>We start with the generic metadata type, <code>M1</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GFromRows</span> r f <span class="ot">=&gt;</span> <span class="dt">GFromRows</span> (<span class="dt">M1</span> i c r) (<span class="dt">M1</span> i c f) <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    gfromRows ::</span> <span class="dt">Vector</span> (<span class="dt">M1</span> i c r a) <span class="ot">-&gt;</span> <span class="dt">M1</span> i c f a</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    gfromRows <span class="ot">=</span> <span class="dt">M1</span> <span class="op">.</span> gfromRows <span class="op">.</span> Data.Vector.map unM1</span></code></pre></div>
<p>Then move on to <code>:*:</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> ( <span class="dt">GFromRows</span> r1 f1</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>         , <span class="dt">GFromRows</span> r2 f2</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>         )</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>         <span class="ot">=&gt;</span> <span class="dt">GFromRows</span> (r1 <span class="op">:*:</span> r2) (f1 <span class="op">:*:</span> f2) <span class="kw">where</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    gfromRows vs <span class="ot">=</span> <span class="kw">let</span> (xs, ys) <span class="ot">=</span> Data.Vector.unzip </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>                                <span class="op">$</span> Data.Vector.map (\(x <span class="op">:*:</span> y) <span class="ot">-&gt;</span> (x, y)) vs</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">in</span> gfromRows xs <span class="op">:*:</span> gfromRows ys</span></code></pre></div>
<p>Finally, onto the representation of fields of constructors, <code>K1</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GFromRows</span> (<span class="dt">K1</span> i r) (<span class="dt">K1</span> i f) <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    gfromRows <span class="ot">=</span> <span class="dt">K1</span> <span class="op">.</span> Data.Vector.map unK1</span></code></pre></div>
<p>Note that the above will not compile. For the instances of <code>M1</code> and <code>:*:</code>, we assumed that <code>r</code> and <code>f</code> already had an instance
of <code>GFromRows</code>. In the instance for <code>K1</code>, the compiler does not know about the relationship between <code>r</code> and <code>f</code> yet. In
some sense, the instance involving the representation <code>K1</code> is the foundation on which other instances are defined.</p>
<p>We can refine our instance by enforcing that <code>f</code> be an array of <code>r</code> using <code>(f ~ Vector r)</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (f <span class="op">~</span> <span class="dt">Vector</span> r) <span class="ot">=&gt;</span> <span class="dt">GFromRows</span> (<span class="dt">K1</span> i r) (<span class="dt">K1</span> i f) <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    gfromRows ::</span> <span class="dt">Vector</span> (<span class="dt">K1</span> i r a) <span class="ot">-&gt;</span> <span class="dt">K1</span> i f a</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    gfromRows <span class="ot">=</span> <span class="dt">K1</span> <span class="op">.</span> Data.Vector.map unK1</span></code></pre></div>
<p>We can now fill in the default implementation of <code>fromRows</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">FromRows</span> t <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fromRows ::</span> <span class="dt">Vector</span> (<span class="dt">Row</span> t) <span class="ot">-&gt;</span> <span class="dt">Frame</span> t</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    default<span class="ot"> fromRows ::</span> ( <span class="dt">Generic</span> (<span class="dt">Row</span> t)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>                        , <span class="dt">Generic</span> (<span class="dt">Frame</span> t)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>                        , <span class="dt">GFromRows</span> (<span class="dt">Rep</span> (<span class="dt">Row</span> t)) (<span class="dt">Rep</span> (<span class="dt">Frame</span> t))</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>                        ) </span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">=&gt;</span> <span class="dt">Vector</span> (<span class="dt">Row</span> t) </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>                     <span class="ot">-&gt;</span> <span class="dt">Frame</span> t</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    fromRows <span class="ot">=</span> to                   <span class="co">-- Turn `Rep (Frame t)` back into `Frame t`</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>             <span class="op">.</span> gfromRows            <span class="co">-- Vector (Rep (Row t)) -&gt; Rep (Frame t)</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>             <span class="op">.</span> Data.Vector.map from <span class="co">-- Turn every row into a `Reo (Row t)`</span></span></code></pre></div>
<p>How can we use this? Behold:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> f</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkUser</span> {<span class="ot"> userFirstName ::</span> <span class="dt">Column</span> f <span class="dt">String</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>             ,<span class="ot"> userLastName  ::</span> <span class="dt">Column</span> f <span class="dt">String</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>             ,<span class="ot"> userAge       ::</span> <span class="dt">Column</span> f <span class="dt">Int</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>             }</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Generic</span>) <span class="co">-- This is new</span></span></code></pre></div>
<p>What’s new here is that we need to derive a <code>Generic</code> instance for <code>User</code>. Then, the instance of <code>FromRows User</code> requires
no method implementation:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromRows</span> <span class="dt">User</span></span></code></pre></div>
<p>Then, we can re-implement <code>buildUserFrame</code> trivially:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">buildUserFrame ::</span> <span class="dt">Vector</span> (<span class="dt">Row</span> <span class="dt">User</span>) <span class="ot">-&gt;</span> <span class="dt">Frame</span> <span class="dt">User</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>buildUserFrame <span class="ot">=</span> fromRows</span></code></pre></div>
<h2 class="title is-2" id="further-work-nesting-dataframes">Further work: nesting dataframes</h2>
<p>The implementation above works, but we assumed that every record type had fields of the form <code>Column f a</code>.
How about nesting dataframes types? Consider this:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Address</span> f</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkAddress</span> {<span class="ot"> addressCivicNumber ::</span> <span class="dt">Column</span> f <span class="dt">Int</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> addressStreetName  ::</span> <span class="dt">Column</span> f <span class="dt">String</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>                }</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Generic</span>)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromRows</span> <span class="dt">Address</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> f</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkStore</span> {<span class="ot"> storeName    ::</span> <span class="dt">Column</span> f <span class="dt">String</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>              ,<span class="ot"> storeAddress ::</span> <span class="dt">Address</span> f</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>              }</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Generic</span>)</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromRows</span> <span class="dt">Store</span> <span class="co">-- type error</span></span></code></pre></div>
<p>Ideally, we would want this <code>Store</code> type above to be equivalent to:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> f</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">MkStore</span> {<span class="ot"> storeName          ::</span> <span class="dt">Column</span> f <span class="dt">String</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>              <span class="co">-- Address gets unpacked into &quot;adjacent&quot; columns</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>              ,<span class="ot"> addressCivicNumber ::</span> <span class="dt">Column</span> f <span class="dt">Int</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>              ,<span class="ot"> addressStreetName  ::</span> <span class="dt">Column</span> f <span class="dt">String</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>              }</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Generic</span>)</span></code></pre></div>
<p>I haven’t figured out how to do this yet, but it would be desirable.</p>
<p><em>This document is a literate Haskell module!</em></p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>R. Lämmel and S. Peyton Jones, <em>Scrap your boilerplate: a practical approach to generic programming</em>. ACM SIGPLAN International Workshop on Types in Language Design and Implementation (2003). <a href="https://www.microsoft.com/en-us/research/publication/scrap-your-boilerplate-a-practical-approach-to-generic-programming">Link</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
                </div>
            </div>
        </div>
        <footer class="footer">
            <div class="content has-text-centered">
                <p>
                    <span class="icon">
                        <i class="fas fa-envelope">
                        </i>
                    </span>
                    <a target="_blank" href="../email.html">
                        e-mail
                    </a>
                     | 
                    <span class="icon">
                        <i class="fab fa-github">
                        </i>
                    </span>
                    <a target="_blank" href="https://github.com/LaurentRDC">
                        GitHub
                    </a>
                     | 
                    <span class="icon">
                        <i class="fab fa-linkedin">
                        </i>
                    </span>
                    <a target="_blank" href="https://www.linkedin.com/in/laurentrdc">
                        LinkedIn
                    </a>
                     | 
                    <span class="icon">
                        <i class="ai ai-researchgate">
                        </i>
                    </span>
                    <a target="_blank" href="https://www.researchgate.net/profile/Laurent_Rene_De_Cotret">
                        ResearchGate
                    </a>
                     | 
                    <span class="icon">
                        <i class="ai ai-orcid">
                        </i>
                    </span>
                    <a target="_blank" href="https://orcid.org/0000-0002-1464-2739">
                        OrcID
                    </a>
                     | 
                    <span class="icon">
                        <i class="ai ai-google-scholar">
                        </i>
                    </span>
                    <a target="_blank" href="https://scholar.google.ca/citations?user=pXFhwioAAAAJ&amp;hl=en">
                        Google Scholar
                    </a>
                </p>
                <p>
                    <span class="icon">
                        <i class="fas fa-rss">
                        </i>
                    </span>
                    <a target="_blank" href="../feed.xml">
                        RSS feed
                    </a>
                     | 
                    <span class="icon">
                        <i class="fas fa-atom">
                        </i>
                    </span>
                    <a target="_blank" href="../atom.xml">
                        Atom feed
                    </a>
                </p>
                <p class="is-small">
                    Page generated on 2025-07-31. 
                    This website was created using free and open-source technologies. 
                    You can learn more about how this website is generated 
                    <a href="../about-site.html">
                        here
                    </a>
                    .
                </p>
                <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
                    <img alt="Creative Commons License" style="border-width:0" src="../images/cc-by-sa.svg">
                </a>
            </div>
        </footer>
    </body>
</html>
