<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Laurent's personal blog</title>
        <link>https://laurentrdc.xyz</link>
        <description><![CDATA[My personal blog on science, math, programming, and other interests.]]></description>
        <atom:link href="https://laurentrdc.xyz/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>2023-03-23
</lastBuildDate>
        <item>
    <title>Efficient rolling statistics</title>
    <link>https://laurentrdc.xyz//posts/rolling-stats.html</link>
    <description><![CDATA[<p>In the context of an array, rolling operations are operations on a set of values which are computed at each index of the array based on a subset of values in the array. A common rolling operation is the rolling mean, also known as the moving average.</p>
<p>The best way to understand is to see it in action. Consider the following list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span></code></pre></div>
<p>The rolling average with a window size of 2 is:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[ (<span class="dv">0</span> <span class="op">+</span> <span class="dv">0</span>)<span class="op">/</span><span class="dv">2</span>, (<span class="dv">0</span> <span class="op">+</span> <span class="dv">1</span>)<span class="op">/</span><span class="dv">2</span>, (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>)<span class="op">/</span><span class="dv">2</span>, (<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)<span class="op">/</span><span class="dv">2</span>, (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)<span class="op">/</span><span class="dv">2</span>, (<span class="dv">4</span> <span class="op">+</span> <span class="dv">3</span>)<span class="op">/</span><span class="dv">2</span>, (<span class="dv">3</span> <span class="op">+</span> <span class="dv">2</span>)<span class="op">/</span><span class="dv">2</span>, (<span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>)<span class="op">/</span><span class="dv">2</span>]</span></code></pre></div>
<p>or</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="fl">1.5</span>, <span class="fl">2.5</span>, <span class="fl">3.5</span>, <span class="fl">3.5</span>, <span class="fl">2.5</span>, <span class="fl">1.5</span>]</span></code></pre></div>
<p>Rolling operations such as the rolling mean tremendously useful at my work. When working with time-series, for example, the rolling mean may be a good indicator to include as part of machine learning feature engineering or trading strategy design. Here’s an example of using the rolling average price of AAPL stock as an indicator:</p>
<figure class="python">
<img src="generated/pandocplot7562145495815374986.png" class="image" alt="Closing price of AAPL stock (solid), with the rolling mean of the closing price using three different windows as an example of indicator (dashed). (Source code)" />
<figcaption aria-hidden="true">Closing price of AAPL stock (solid), with the rolling mean of the closing price using three different windows as an example of indicator (dashed). (<a href="generated/pandocplot7562145495815374986.src.html">Source code</a>)</figcaption>
</figure>
<p>The problem is that rolling operations can be rather slow if implemented improperly. In this post, I’ll show you how to implement efficient rolling statistics using a method based on <em>recurrence relations</em>.</p>
<p>In principle, a general rolling function for lists might have the following type signature:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rolling ::</span> <span class="dt">Int</span>        <span class="co">-- ^ Window length</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> b) <span class="co">-- ^ Rolling function, e.g. the mean or the standard deviation</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> [a]        <span class="co">-- ^ An input list of values</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> [b]        <span class="co">-- ^ An output list of values</span></span></code></pre></div>
<p>In this hypothetical scenario, the rolling function of type <code class="sourceCode haskell">[a] <span class="ot">-&gt;</span> b</code> receives a sublist of length <span class="math inline">\(M\)</span>, the window length. The problem is, if the input list has size <span class="math inline">\(N\)</span>, and the window has length <span class="math inline">\(M\)</span>, the complexity of this operation is at best <span class="math inline">\(\mathcal{O}(N \cdot M)\)</span>. Even if you’re using a data structure which is more efficient than a list – an array, for example –, this is still inefficient.</p>
<p>Let’s see how to make this operation <span class="math inline">\(\mathcal{O}(N)\)</span>, i.e. constant in the window length!</p>
<h2 class="title is-2" id="recurrence-relations-and-the-rolling-average">Recurrence relations and the rolling average</h2>
<p>The recipe for these algorithms is construct the recurrence relation of the operation. A recurrence relation is a way to describe a series by expressing how a term at index <span class="math inline">\(i\)</span> is related to the term at index <span class="math inline">\(i-1\)</span>.</p>
<p>Let proceed by example. Consider a series of values <span class="math inline">\(X\)</span> like so:</p>
<p><span class="math display">\[
    X = \left[ x_0, x_1, ...\right]
\]</span></p>
<p>We want to calculate the rolling average <span class="math inline">\(\bar{X} = \left[ \bar{x}_0, \bar{x}_1, ... \right]\)</span> of series <span class="math inline">\(X\)</span> with a window length <span class="math inline">\(N\)</span>. The equation for the <span class="math inline">\(j\)</span><sup>th</sup> term, <span class="math inline">\(\bar{x}_j\)</span> is given by:</p>
<p><span class="math display">\[
    \bar{x}_j = \frac{1}{N}\sum_{i=j - N + 1}^{N} x_i = \frac{1}{N} \sum \left[ x_{j - N + 1}, x_{j - N + 2}, ..., x_{j} \right]
\]</span></p>
<p>Now let’s look at the equation for the <span class="math inline">\((j-1)\)</span><sup>th</sup> term:</p>
<p><span class="math display">\[
    \bar{x}_{j-1} = \frac{1}{N}\sum_{i=j - N}^{j-1} x_i = \frac{1}{N} \sum \left[ x_{j - N}, x_{j - N + 1}, ..., x_{j-1} \right]
\]</span></p>
<p>Note the large overlap between the computation of <span class="math inline">\(\bar{x}_j\)</span> and <span class="math inline">\(\bar{x}_{j-1}\)</span>; in both cases, you need to sum up <span class="math inline">\(\left[ x_{j-N+1}, x_{j-N+2}, ..., x_{j-1} \right]\)</span></p>
<p>Given that the overlap is very large, let’s take the difference between two consecutive terms, <span class="math inline">\(\bar{x}_j\)</span> and <span class="math inline">\(\bar{x}_{j-1}\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
    \bar{x}_j - \bar{x}_{j-1} &amp;= \frac{1}{N} \sum \left[ x_{j - N + 1}, x_{j - N + 2}, ..., x_j \right] - \frac{1}{N} \sum \left[ x_{j - N}, x_{j - N + 1}, ..., x_{j-1} \right] \\
                              &amp;= \frac{1}{N} \sum \left[ -x_{j-N} + x_{j - N + 1} - x_{j - N + 1} + x_{j - N + 2} - x_{j - N + 2} + ... + x_{j-1} - x_{j-1} + x_j\right] \\
                              &amp;= \frac{1}{N} ( x_{j} - x_{j - N} )
\end{aligned}
\]</span></p>
<p>Rewriting a little:</p>
<p><span class="math display">\[
    \bar{x}_j = \bar{x}_{j-1} + \frac{1}{N} ( x_j - x_{j-N} )
\]</span></p>
<p>This is the recurrence relation of the rolling average with a window of length <span class="math inline">\(N\)</span>. It tells us that for every term of the rolling average series <span class="math inline">\(\bar{X}\)</span>, we only need to involve two terms of the original series <span class="math inline">\(X\)</span>, regardless of the window. Awesome!</p>
<h4 class="title is-4" id="haskell-implementation">Haskell implementation</h4>
<p>Let’s implement this in Haskell. We’ll use the <a href="https://hackage.haskell.org/package/vector"><code>vector</code></a> library which is much faster than lists for numerical calculations like this, and comes with some combinatiors which make it pretty easy to implement the rolling mean. Regular users of <code>vector</code> will notice that the recurrence relation above fits the <code>scanl</code> use-case. If you’re unfamiliar, <code>scanl</code> is a function which looks like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">scanl</span><span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="co">-- ^ Combination function</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> b             <span class="co">-- ^ Starting value</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">Vector</span> a      <span class="co">-- ^ Input</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">Vector</span> b      <span class="co">-- ^ Output</span></span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> Vector.scanl (<span class="op">+</span>) <span class="dv">0</span> (Vector.fromList [<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">10</span>])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">12</span>, <span class="dv">22</span>]</span></code></pre></div>
<p>If we decompose the example:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>[    <span class="dv">1</span>,     <span class="dv">5</span>,    <span class="dv">12</span>,      <span class="dv">22</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span> <span class="op">+</span> <span class="dv">1</span>, <span class="dv">1</span> <span class="op">+</span> <span class="dv">4</span>, <span class="dv">5</span> <span class="op">+</span> <span class="dv">7</span>, <span class="dv">12</span> <span class="op">+</span> <span class="dv">10</span>]</span></code></pre></div>
<p><code>scanl</code> is an accumulation from left to right, where the “scanned” term at index <code>i</code> depends on the value of the input at indices <code>i</code> and the scanned term at <code>i-1</code>. This is perfect to represent recurrence relations. Note that in the case of the rolling mean recurrence relation, we’ll need access to the value at index <code>i</code> and <code>i - N</code>, where again <code>N</code> is the length of the window. The canonical way to operate on more than one array at once elementwise is the <code>zip*</code> family of functions.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- from the `vector` library</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Vector</span> ( <span class="dt">Vector</span> )   </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Perform the rolling mean calculation on a vector.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">rollingMean ::</span> <span class="dt">Int</span>            <span class="co">-- ^ Window length</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span>  <span class="co">-- ^ Input series</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span>  </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>rollingMean window vs</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">let</span> w     <span class="ot">=</span> <span class="fu">fromIntegral</span> window </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Starting point is the mean of the first complete window</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>          start <span class="ot">=</span> Vector.sum (Vector.take window vs) <span class="op">/</span> w</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Consider the recurrence relation mean[i] = mean[i-1] + (edge - lag)/w </span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- where w    = window length</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>          <span class="co">--       edge = vs[i]</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>          <span class="co">--       lag  = vs[i - w]</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>          edge <span class="ot">=</span> Vector.drop window vs</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>          lag  <span class="ot">=</span> Vector.take (Vector.length vs <span class="op">-</span> window) vs</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- mean[i] = mean[i-1] + diff, where diff is:</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>          diff <span class="ot">=</span> Vector.zipWith (\p n <span class="ot">-&gt;</span> (p <span class="op">-</span> n)<span class="op">/</span>w) edge lag</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- The rolling mean for the elements at indices i &lt; window is set to 0</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> Vector.replicate (window <span class="op">-</span> <span class="dv">1</span>) <span class="dv">0</span> <span class="op">&lt;&gt;</span> Vector.scanl (<span class="op">+</span>) start diff</span></code></pre></div>
<p>With this function, we can compute the rolling mean like so:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">import</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> rollingMean <span class="dv">2</span> <span class="op">$</span> Vector.fromList [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>[<span class="fl">0.0</span>,<span class="fl">1.5</span>,<span class="fl">2.5</span>,<span class="fl">3.5</span>,<span class="fl">4.5</span>]</span></code></pre></div>
<h4 class="title is-4" id="complexity-analysis">Complexity analysis</h4>
<p>Let’s say the window length is <span class="math inline">\(N\)</span> and the input array length is <span class="math inline">\(n\)</span>. The naive algorithm has complexity <span class="math inline">\(\mathcal{O}(n \cdot N)\)</span>. On the other hand, <code>rollingMean</code> has a complexity of <span class="math inline">\(\mathcal{O}(n + N)\)</span>:</p>
<ul>
<li><code>Vector.sum</code> to compute <code>start</code> is <span class="math inline">\(\mathcal{O}(N)\)</span>;</li>
<li><code>Vector.replicate (window - 1)</code> has order <span class="math inline">\(\mathcal{O}(N)\)</span></li>
<li><code>Vector.drop</code> and <code>Vector.take</code> are both <span class="math inline">\(\mathcal{O}(1)\)</span>;</li>
<li><code>Vector.scanl</code> and <code>Vector.zipWith</code> are both <span class="math inline">\(\mathcal{O}(n)\)</span> (and in practice, these operations should get fused to a single pass);</li>
</ul>
<p>However, usually <span class="math inline">\(N &lt;&lt; n\)</span>. For example, at work, we typically roll 10+ years of data with a window on the order of days / weeks. Therefore, we have that <code>rollingMean</code> scales linearly with the length of the input (<span class="math inline">\(\mathcal{O}(n)\)</span>)</p>
<h2 class="title is-2" id="efficient-rolling-variance">Efficient rolling variance</h2>
<p>Now that we’ve developed a procedure on how to determine an efficient rolling algorithm, let’s do it for the (unbiased) variance.</p>
<p>Again, consider a series of values:</p>
<p><span class="math display">\[
    X = \left[ x_0, x_1, ...\right]
\]</span></p>
<p>We want to calculate the rolling variance <span class="math inline">\(\sigma^2(X)\)</span> of series <span class="math inline">\(X\)</span> with a window length <span class="math inline">\(N\)</span>. The equation for the <span class="math inline">\(j\)</span><sup>th</sup> term, <span class="math inline">\(\sigma^2_j\)</span> is given by:</p>
<p><span class="math display">\[
    \sigma^2_j = \frac{1}{N - 1}\sum_{i=j - N + 1}^{j} (x_i - \bar{x}_j)^2 = \frac{1}{N-1} \sum \left[ (x_{j - N + 1} - \bar{x}_j)^2, ..., (x_j - \bar{x}_j)^2 \right]
\]</span></p>
<p>where <span class="math inline">\(\bar{x}_i\)</span> is the rolling mean at index <span class="math inline">\(i\)</span>, just like in the previous section. Let’s simplify a bit by expanding the squares:</p>
<p><span class="math display">\[
\begin{aligned}
    (N - 1) ~ \sigma^2_j &amp;= \sum_{i=j-N+1}^{j} (x_i - \bar{x}_j)^2 \\
                         &amp;= N\bar{x}^2_j + \sum_{i=j - N + 1}^{j} x^2_i - 2 x_i \bar{x}_j
\end{aligned}
\]</span></p>
<p>We note here that <span class="math inline">\(\sum_{i=j - N + 1}^{j} x_i \equiv N \bar{x}_j\)</span>, which allows to simplify the equation further:</p>
<p><span class="math display">\[
\begin{aligned}
    (N - 1) ~ \sigma^2_j &amp;= N\bar{x}^2_j - 2 N \bar{x}^2_j + \sum_{i=j - N + 1}^{j} x^2_i  \\
                         &amp;= -N\bar{x}^2_j + \sum_{i=j - N + 1}^{j} x^2_i 
\end{aligned}
\]</span></p>
<p>This leads to the following difference between consecutive rolling unbiased variance terms:</p>
<p><span class="math display">\[
\begin{aligned}
(N - 1) \left( \sigma^2_j - \sigma^2_{j-1} \right) &amp;= N\bar{x}^2_{j - 1} - N\bar{x}^2_j + \sum_{i=j - N + 1}^{j} x^2_i - \sum_{i&#39;=j - N}^{j-1} x^2_{i&#39;} \\
                                                   &amp;= N\bar{x}^2_{j - 1} - N\bar{x}^2_j + x^2_j - x^2_{j-N}
\end{aligned}
\]</span></p>
<p>and therefore, the recurrence relation:</p>
<p><span class="math display">\[
\sigma^2_j = \sigma^2_{j-1} + \frac{1}{N-1} \left[ N\bar{x}^2_{j - 1} - N\bar{x}^2_j + x^2_j - x^2_{j - N} \right] 
\]</span></p>
<p>This recurrence relation looks pretty similar to the rolling mean recurrence relation, with the added wrinkle that you need to know the rolling mean in advance.</p>
<h4 class="title is-4" id="haskell-implementation-1">Haskell implementation</h4>
<p>Let’s implement this in Haskell again. We can re-use our <code>rollingMean</code>. We’ll also need to compute the unbiased variance in the starting window; I’ll use the <code>statistics</code> library for brevity, but it’s easy to implement yourself if you care about minimizing dependencies.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- from the `vector` library</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Vector</span> ( <span class="dt">Vector</span> )   </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- from the `statistics` library</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Statistics.Sample</span> ( varianceUnbiased )</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ot">rollingMean ::</span> <span class="dt">Int</span>          </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>rollingMean <span class="ot">=</span> (<span class="op">...</span>)  <span class="co">-- see above</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Perform the rolling unbiased variance calculation on a vector.</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="ot">rollingVar ::</span> <span class="dt">Int</span>          </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>rollingVar window vs</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">let</span> start   <span class="ot">=</span> varianceUnbiased <span class="op">$</span> Vector.take window vs</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>          n       <span class="ot">=</span> <span class="fu">fromIntegral</span> window</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>          ms      <span class="ot">=</span> rollingMean window vs</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Rolling mean terms leading by N</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>          ms_edge <span class="ot">=</span> Vector.drop window ms</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Rolling mean terms leading by N - 1</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>          ms_lag  <span class="ot">=</span> Vector.drop (window <span class="op">-</span> <span class="dv">1</span>) ms</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Values leading by N</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>          xs_edge <span class="ot">=</span> Vector.drop window vs</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Values leading by 0</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>          xs_lag  <span class="ot">=</span> vs</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- Implementation of the recurrence relation, minus the previous term in the series</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- There&#39;s no way to make the following look nice, sorry.</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- N * \bar{x}^2_{N-1} - N * \bar{x}^2_{N} + x^2_N - x^2_0</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>          term xbar_nm1 xbar_n x_n x_0 <span class="ot">=</span> (n <span class="op">*</span> (xbar_nm1<span class="op">**</span><span class="dv">2</span>) <span class="op">-</span> n <span class="op">*</span> (xbar_n <span class="op">**</span> <span class="dv">2</span>) <span class="op">+</span> x_n<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> x_0<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span>(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- The rolling variance for the elements at indices i &lt; window is set to 0</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> Vector.replicate (window <span class="op">-</span> <span class="dv">1</span>) <span class="dv">0</span> <span class="op">&lt;&gt;</span> Vector.scanl (<span class="op">+</span>) start (Vector.zipWith4 term ms_lag ms_edge xs_edge xs_lag)</span></code></pre></div>
<p>Note that it may be benificial to reformulate the <span class="math inline">\(N\bar{x}^2_{j - 1} - N\bar{x}^2_j + x^2_j - x^2_{j - N}\)</span> part of the recurrence relation to optimize the <code>rollingVar</code> function. For example, is it faster to minimize the number of exponentiations, or multiplications? I do not know, and leave further optimizations aside.</p>
<h4 class="title is-4" id="complexity-analysis-1">Complexity analysis</h4>
<p>Again, let’s say the window length is <span class="math inline">\(N\)</span> and the input array length is <span class="math inline">\(n\)</span>. The naive algorithm still has complexity <span class="math inline">\(\mathcal{O}(n \cdot N)\)</span>. On the other hand, <code>rollingVar</code> has a complexity of <span class="math inline">\(\mathcal{O}(n + N)\)</span>:</p>
<ul>
<li><code>varianceUnbiased</code> to compute <code>start</code> is <span class="math inline">\(\mathcal{O}(N)\)</span>;</li>
<li><code>Vector.replicate (window - 1)</code> has order <span class="math inline">\(\mathcal{O}(N)\)</span></li>
<li><code>Vector.drop</code> and <code>Vector.take</code> are both <span class="math inline">\(\mathcal{O}(1)\)</span>;</li>
<li><code>Vector.scanl</code> and <code>Vector.zipWith4</code> are both <span class="math inline">\(\mathcal{O}(n)\)</span> (and in practice, these operations should get fused to a single pass);</li>
</ul>
<p>Since usually <span class="math inline">\(N &lt;&lt; n\)</span>, as before, we have that <code>rollingVar</code> scales linearly with the length of the input (<span class="math inline">\(\mathcal{O}(n)\)</span>).</p>
<h2 class="title is-2" id="bonus-rolling-sharpe-ratio">Bonus: rolling Sharpe ratio</h2>
<p>The Sharpe ratio<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> is a common financial indicator of return on risk. It’s definition is simple. Consider returns (also known as PnL) in a set <span class="math inline">\(X\)</span>. The Sharpe ratio <span class="math inline">\(S(X)\)</span> of these returns is:</p>
<p><span class="math display">\[
S(X) = \frac{\bar{X}}{\sigma_X} 
\]</span></p>
<p>For ordered returns <span class="math inline">\(X = \left[ x_0, x_1, ... \right]\)</span>, the rolling Sharpe ratio at index <span class="math inline">\(j\)</span> is:</p>
<p><span class="math display">\[
    S_j = \frac{\bar{x}_j}{\sigma_j}
\]</span></p>
<p>where <span class="math inline">\(\bar{x}_j\)</span> and <span class="math inline">\(\sigma_j\)</span> are the rolling mean and standard deviation at index <span class="math inline">\(j\)</span>, respectively.</p>
<p>Since the rolling variance requires knowledge of the rolling mean, we can easily compute the rolling Sharpe ratio by modifying the implementation of <code>rollingVariance</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- from the `vector` library</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Vector</span> ( <span class="dt">Vector</span> )   </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vector</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- from the `statistics` library</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Statistics.Sample</span> ( varianceUnbiased )</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">rollingMean ::</span> <span class="dt">Int</span>          </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>rollingMean <span class="ot">=</span> (<span class="op">...</span>)  <span class="co">-- see above</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ot">rollingSharpe ::</span> <span class="dt">Int</span>          </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>              <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>rollingSharpe window vs</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">let</span> start   <span class="ot">=</span> varianceUnbiased <span class="op">$</span> Vector.take window vs</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>          n       <span class="ot">=</span> <span class="fu">fromIntegral</span> window</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>          ms      <span class="ot">=</span> rollingMean window vs</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- The following expressions are taken from rollingVar</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>          ms_edge <span class="ot">=</span> Vector.drop window ms</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>          ms_lag  <span class="ot">=</span> Vector.drop (window <span class="op">-</span> <span class="dv">1</span>) ms</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>          xs_edge <span class="ot">=</span> Vector.drop window vs</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>          xs_lag  <span class="ot">=</span> vs</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>          term xbar_nm1 xbar_n x_n x_0 <span class="ot">=</span> (n <span class="op">*</span> (xbar_nm1<span class="op">**</span><span class="dv">2</span>) <span class="op">-</span> n <span class="op">*</span> (xbar_n <span class="op">**</span> <span class="dv">2</span>) <span class="op">+</span> x_n<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> x_0<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span>(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- standard deviation from variance</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>          std <span class="ot">=</span> <span class="fu">sqrt</span> <span class="op">&lt;$&gt;</span> Vector.scanl (<span class="op">+</span>) start (Vector.zipWith4 term ms_lag ms_edge xs_edge xs_lag)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- The rolling Sharpe ratio for the elements at indices i &lt; window is set to 0</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> Vector.replicate (window <span class="op">-</span> <span class="dv">1</span>) <span class="dv">0</span> <span class="op">&lt;&gt;</span> Vector.zipWith (<span class="op">/</span>) (Vector.drop window ms) std</span></code></pre></div>
<h2 class="title is-2" id="conclusion">Conclusion</h2>
<p>In this blog post, I’ve shown you a recipe to design rolling statistics algorithms which are efficient (i.e. <span class="math inline">\(\mathcal{O}(n)\)</span>) based on recurrence relations. Efficient rolling statistics as implemented in this post are an essential part of backtesting software, which is software to test trading strategies.</p>
<p><em>All code is available in this <a href="/files/rolling-stats/Rolling.hs">Haskell module</a>.</em></p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>William F. Sharpe. <em>Mutual Fund Performance</em>. Journal of Business, <strong>31</strong> (1966). <a href="https://doi.org/10.1086/294846">DOI: 10.1086/294846</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
    <pubDate>Thu, 23 Mar 2023 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/rolling-stats.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>Filtering noise with discrete wavelet transforms</title>
    <link>https://laurentrdc.xyz//posts/wavelet-filtering.html</link>
    <description><![CDATA[<div class="message is-link"><div class="message-body"><h2>On this page</h2><p><ul>
<li><a href="#integral-transforms" id="toc-integral-transforms">Integral transforms</a>
<ul>
<li><a href="#discretization" id="toc-discretization">Discretization</a></li>
</ul></li>
<li><a href="#using-the-discrete-fourier-transform-to-filter-noise" id="toc-using-the-discrete-fourier-transform-to-filter-noise">Using the discrete Fourier transform to filter noise</a></li>
<li><a href="#discrete-wavelet-transforms" id="toc-discrete-wavelet-transforms">Discrete wavelet transforms</a></li>
<li><a href="#filtering-using-the-discrete-wavelet-transform" id="toc-filtering-using-the-discrete-wavelet-transform">Filtering using the discrete wavelet transform</a></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a></li>
</ul></p></div></div><p>All experimental data contains noise. Distinguishing between measurement and noise is an important component of any data analysis pipeline. However, different noise-filtering techniques are suited to different categories of noise.</p>
<p>In this post, I’ll show you a class of filtering technique, based on discrete wavelet transforms, which is suited to noise that cannot be filtered away with more traditional techniques – such as ones that rely on the Fourier transform. This has been important in my past research<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, and I hope that this can help you too.</p>
<h2 class="title is-2" id="integral-transforms">Integral transforms</h2>
<p>A large category of filtering techniques are based on <em>integral transforms</em>. Broadly speaking, an integral transform <span class="math inline">\(T\)</span> is an operation that is performed on a function <span class="math inline">\(f\)</span> and builds a function <span class="math inline">\(T\left[ f\right]\)</span> which is defined on a variable <span class="math inline">\(s\)</span>, such that:</p>
<p><span class="math display">\[
    T\left[ f \right](s) = \int dt ~ f(t) \cdot K(t, s)
\]</span></p>
<p>Here, <span class="math inline">\(K\)</span> (for kernel) is a function which “selects” which parts of <span class="math inline">\(f(t)\)</span> are important as a fixed <span class="math inline">\(s\)</span>. Note that for an integral transform to be useful as a filter, we’ll need the ability to invert the transformation, i.e. there exists an inverse kernel <span class="math inline">\(K^{-1}(s, t)\)</span> such that:</p>
<p><span class="math display">\[
    f(t) = \int ds ~ \left( T \left[ f\right] (s) \right) \cdot K^{-1}(s,t)
\]</span></p>
<p>All of this was very abstract, so let’s look at a concrete example: the Fourier transform. The Fourier transform is an integral transform where<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>:</p>
<p><span class="math display">\[
    \begin{align}
        K(t, \omega)      &amp;\equiv \frac{e^{-i \omega t}}{\sqrt{2 \pi}}\\
        K^{-1}(\omega, t) &amp;\equiv  e^{i \omega t}\\
        \omega            &amp; \in \mathbb{R}
    \end{align}
\]</span></p>
<p>There are many other integral transforms, such as:</p>
<ul>
<li>The Laplace transform (<span class="math inline">\(K(t, s) \equiv e^{- s t}\)</span>) which is useful to solve linear ordinary differential equations;</li>
<li>The Legendre transforms (<span class="math inline">\(K_n(t, s) \equiv P_n(s)\)</span>, where <span class="math inline">\(P_n\)</span> is the n<sup>th</sup> <a href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre polynomial</a>) which is used to solve for electron motion in hydrogen atoms;</li>
<li>The Radon transform (for which I cannot write down a kernel) which is used to analyze <a href="https://scikit-image.org/docs/stable/auto_examples/transform/plot_radon_transform.html">computed tomography data</a>.</li>
</ul>
<p>So why are integral transforms interesting? Well, depending on the function <span class="math inline">\(f(t)\)</span> you want to transform, you might end up with a representation of <span class="math inline">\(f\)</span> in the transformed space, <span class="math inline">\(T \left[ f\right] (s)\)</span>, which has nice properties! Re-using the Fourier transform for a simple, consider a function made up of two well-defined frequencies:
<span class="math display">\[
    f(t) \equiv e^{-i ~ 2t} + e^{-i ~ 5t}
\]</span>
The representation of <span class="math inline">\(f(t)\)</span> in frequency space – the Fourier transform of <span class="math inline">\(f\)</span>, <span class="math inline">\(F\left[ f\right](\omega)\)</span> – is very simple:
<span class="math display">\[
    F\left[ f\right](\omega) = \sqrt{2 \pi} \left[ \delta(\omega - 2) + \delta(\omega - 5) \right]
\]</span>
The Fourier transform of <span class="math inline">\(f\)</span> is perfectly localized in frequency space, being zero everywhere except at <span class="math inline">\(\omega=2\)</span> and <span class="math inline">\(\omega=5\)</span>. Functions composed of infinite waves (like the example above) always have the nice property of being localized in frequency space, which makes it easy to manipulate them… like filtering some of their components away!</p>
<h3 class="title is-3" id="discretization">Discretization</h3>
<p>It is much more efficient to use discretized versions of integral transforms on computers. Loosely speaking, given a discrete signal composed of <span class="math inline">\(N\)</span> terms <span class="math inline">\(x_0\)</span>, …, <span class="math inline">\(x_{N-1}\)</span>:
<span class="math display">\[
    T\left[ f \right](k) = \sum_n x_n \cdot K(n, k)
\]</span>
i.e. the integral is now a finite sum. For example, the discrete Fourier transform of the signal <span class="math inline">\(x_n\)</span>, <span class="math inline">\(X_k\)</span>, can be written as:
<span class="math display">\[
    X_k = \sum_n x_n \cdot e^{-i 2 \pi k n / N}
\]</span>
and its inverse becomes:
<span class="math display">\[
    x_n = \frac{1}{N}\sum_k X_k \cdot e^{i 2 \pi k n / N}
\]</span>
This is the definition used by <a href="https://numpy.org/doc/stable/reference/routines.fft.html#module-numpy.fft">numpy</a>, for example. Let’s use this definition to compute the discrete Fourier transform of <span class="math inline">\(f(t) \equiv e^{-i ~ 2t} + e^{-i ~ 5t}\)</span>:</p>
<figure class="python">
<img src="generated/pandocplot16503602130599803112.png" class="image" alt="Top: Signal which is composed of two natural frequencies. Bottom: Discrete Fourier transform of the top signal, showing two natural frequencies. (Source code)" />
<figcaption aria-hidden="true"><strong>Top</strong>: Signal which is composed of two natural frequencies. <strong>Bottom</strong>: Discrete Fourier transform of the top signal, showing two natural frequencies. (<a href="generated/pandocplot16503602130599803112.src.html">Source code</a>)</figcaption>
</figure>
<h2 class="title is-2" id="using-the-discrete-fourier-transform-to-filter-noise">Using the discrete Fourier transform to filter noise</h2>
<p>Let’s add some noise to our signal and see how we can use the discrete Fourier transform to filter it away. The discrete Fourier transform is most effective if your noise has some nice properties in frequency space. For example, consider high-frequency noise:
<span class="math display">\[
    N(t) = \sum_{\omega=20}^{50} \sin(\omega t + \phi_{\omega})
\]</span>
where <span class="math inline">\(\phi_\omega\)</span> are random phases, one for each frequency component of the noise. While the signal looks very noisy, it’s very obvious in frequency-space what is noise and what is signal:</p>
<figure class="python">
<img src="generated/pandocplot13940388476741153044.png" class="image" alt="Top: Noisy signal (red) with the pure signal shown in comparison. Bottom: Discrete Fourier transform of the noisy signal shows that noise is confined to a specific region of frequency space. (Source code)" />
<figcaption aria-hidden="true"><strong>Top</strong>: Noisy signal (red) with the pure signal shown in comparison. <strong>Bottom</strong>: Discrete Fourier transform of the noisy signal shows that noise is confined to a specific region of frequency space. (<a href="generated/pandocplot13940388476741153044.src.html">Source code</a>)</figcaption>
</figure>
<p>The basics of filtering is as follows: set the transform of a signal to 0 in regions which are thought to be undesirable. In the case of the Fourier transform, this is known as a <em>band-pass filter</em>; frequency components of a particular frequency <em>band</em> are passed-through unchanged, and frequency components outside of this band are zeroed. Special names are given to band-pass filters with no lower bound (low-pass filter) and no upper bound (high-pass filter). We can express this filtering as a window function <span class="math inline">\(W_k\)</span> in the inverse discrete Fourier transform:
<span class="math display">\[
    x_{n}^{\text{filtered}} = \frac{1}{N}\sum_k W_k \cdot X_k \cdot e^{i 2 \pi k n / N}
\]</span>
In the case of the plot above, we want to apply a low-pass filter with a cutoff at <span class="math inline">\(\omega=10\)</span>. That is:
<span class="math display">\[
W_k = \left\{ \begin{array}{cl}
    1 &amp; : \ |k| \leq 10 \\
    0 &amp; : \ |k| &gt; 10
\end{array} \right.
\]</span>
Visually:</p>
<figure class="python">
<img src="generated/pandocplot16514232093866695677.png" class="image" alt="Top: Noisy signal with the pure signal shown in comparison. Middle: Discrete Fourier transform of the noisy signal. The band of our band-pass filter is shown, with a cutoff of \omega=10. All Fourier components in the zeroed region are set to 0 before performing the inverse discrete Fourier transform. Bottom: Comparison between the filtered signal and the pure signal. The only (small) deviations can be observed at the edges. (Source code)" />
<figcaption aria-hidden="true"><strong>Top</strong>: Noisy signal with the pure signal shown in comparison. <strong>Middle</strong>: Discrete Fourier transform of the noisy signal. The band of our band-pass filter is shown, with a cutoff of <span class="math inline">\(\omega=10\)</span>. All Fourier components in the zeroed region are set to 0 before performing the inverse discrete Fourier transform. <strong>Bottom</strong>: Comparison between the filtered signal and the pure signal. The only (small) deviations can be observed at the edges. (<a href="generated/pandocplot16514232093866695677.src.html">Source code</a>)</figcaption>
</figure>
<p>The lesson here is that filtering signals using a discretized integral transform (like the discrete Fourier transform) consists in:</p>
<ol type="1">
<li>Performing a forward transform;</li>
<li>Modifying the transformed signal using a window function, usually by zeroing components;</li>
<li>Performing the inverse transform on the modified signal.</li>
</ol>
<h2 class="title is-2" id="discrete-wavelet-transforms">Discrete wavelet transforms</h2>
<p>Discrete wavelet transforms are a class of discrete transforms which decomposes signals into a sum of wavelets. While the complex exponential functions which make up the Fourier transform are localized in frequency but infinite in space, wavelets are localized in both time space and frequency space.</p>
<p>In order to generate the basis wavelets, the original wavelet is stretched. This is akin to the Fourier transform, where the sine/cosine basis functions are ‘stretched’ by decreasing their frequency. In technical terms, the amount of ‘stretch’ is called the <strong>level</strong>. For example, the discrete wavelet transform using the <code>db4</code><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> wavelet up to level 5 is the decomposition of a signal into the following wavelets:</p>
<figure class="python">
<img src="generated/pandocplot6990348680171478896.png" class="image" alt="Five of the db4 basis wavelets shown. As the level increases, the wavelet is stretched such that it can represent lower-frequency components of a signal. (Source code)" />
<figcaption aria-hidden="true">Five of the <code>db4</code> basis wavelets shown. As the level increases, the wavelet is stretched such that it can represent lower-frequency components of a signal. (<a href="generated/pandocplot6990348680171478896.src.html">Source code</a>)</figcaption>
</figure>
<p>In practice, discrete wavelet transforms are expressed as two transforms per level. This means that a discrete wavelet transform of level 1 gives back two sets of coefficients. One set of coefficient contains the low-frequency components of the signal, and are usually called the <em>approximate coefficients</em>. The other set of coefficients contains the high-frequency components of the signal, and are usually called the <em>detail coefficients</em>. A wavelet transform of level 2 is done by taking the approximate coefficients of level 1, and transforming them using a stretched wavelet into two sets of coefficients: the approximate coefficients of level 2, and the detail coefficients of level 2. Therefore, a signal transformed using a wavelet transform of level <span class="math inline">\(N\)</span> has <span class="math inline">\(N\)</span> sets of coefficients: the approximate and detail coefficients of level <span class="math inline">\(N\)</span>, and the detail coefficients of levels <span class="math inline">\(N-1\)</span>, <span class="math inline">\(N-2\)</span>, …, <span class="math inline">\(1\)</span>.</p>
<h2 class="title is-2" id="filtering-using-the-discrete-wavelet-transform">Filtering using the discrete wavelet transform</h2>
<p>The discrete Fourier transform excels at filtering away noise which has nice properties in frequency space. This is isn’t always the case in practice; for example, noise may have frequency components which overlap with the signal we’re looking for. This was the case in my research on ultrafast electron diffraction of polycrystalline samples<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, where the ‘noise’ was a trendline which moved over time, and whose frequency components overlapped with diffraction pattern we were trying to isolate.</p>
<p>As an example, let’s use <a href="/files/wavelet-filter/diffraction.csv">real diffraction data</a> and we’ll pretend this is a time signal, to keep the units familiar. We’ll take a look at some really annoying noise: normally-distributed white noise drawn from this distribution<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>:
<span class="math display">\[
    P(x) = \frac{1}{\sqrt{2 \pi}} \exp{-\frac{(x + 1/2)^2}{2}}
\]</span></p>
<p>Visually:</p>
<figure class="python">
<img src="generated/pandocplot11205455165116676194.png" class="image" alt="Top: Example signal with added synthetic noise. Bottom: Frequency spectrum of both the pure signal and the noise, showing overlap. This figure shows that filtering techniques based on the Fourier transform would not help in filtering the noise in this signal. (Source code)" />
<figcaption aria-hidden="true"><strong>Top</strong>: Example signal with added synthetic noise. <strong>Bottom</strong>: Frequency spectrum of both the pure signal and the noise, showing overlap. This figure shows that filtering techniques based on the Fourier transform would not help in filtering the noise in this signal. (<a href="generated/pandocplot11205455165116676194.src.html">Source code</a>)</figcaption>
</figure>
<p>This example shows a common situation: realistic noise whose frequency components overlap with the signal we’re trying to isolate. We wouldn’t be able to use filtering techniques based on the Fourier transform.</p>
<p>Now let’s look at a particular discrete wavelet transform, with the underlying wavelet <code>sym17</code>. Decomposing the noisy signal up to level 3, we get four components:</p>
<figure class="python">
<img src="generated/pandocplot18429196077837909023.png" class="image" alt="All coefficients from a discrete wavelet transform up to level 3 with wavelet sym17. (Source code)" />
<figcaption aria-hidden="true">All coefficients from a discrete wavelet transform up to level 3 with wavelet <code>sym17</code>. (<a href="generated/pandocplot18429196077837909023.src.html">Source code</a>)</figcaption>
</figure>
<p>Looks like the approximate coefficients at level 3 contain all the information we’re looking for. Let’s set all detail coefficients to 0, and invert the transform:</p>
<figure class="python">
<img src="generated/pandocplot6127349031887225015.png" class="image" alt=" (Source code)" />
<figcaption aria-hidden="true"> (<a href="generated/pandocplot6127349031887225015.src.html">Source code</a>)</figcaption>
</figure>
<p>That’s looking pretty good! Not perfect of course, which I expected because we’re using real data here.</p>
<h2 class="title is-2" id="conclusion">Conclusion</h2>
<p>In this post, I’ve tried to give some of the intuition behind filtering signals using discrete wavelet transforms as an analogy to filtering with the discrete Fourier transform.</p>
<p>This was only a basic explanation. There is so much more to wavelet transforms. There are many classes of wavelets with different properties, some of which<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> are very useful when dealing with higher-dimensional data (e.g. images and videos). If you’re dealing with noisy data, it won’t hurt to try and see if wavelets will help you understand it!</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><strong>L. P. René de Cotret</strong> and B. J. Siwick, <em>A general method for baseline-removal in ultrafast electron powder diffraction data using the dual-tree complex wavelet transform</em>, Struct. Dyn. <strong>4</strong> (2017) <a href="http://scitation.aip.org/content/aca/journal/sdy/4/4/10.1063/1.4972518">DOI:10.1063/1.4972518</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>M. R. Otto, <strong>L. P. René de Cotret</strong>, <em>et al</em>, <em>How optical excitation controls the structure and properties of vanadium dioxide</em>, PNAS (2018) <a href="https://doi.org/10.1073/pnas.1808414115">DOI: 10.1073/pnas.1808414115</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Note that it is traditional in physics to represent the transform variable as <span class="math inline">\(\omega\)</span> instead of <span class="math inline">\(s\)</span>. If <span class="math inline">\(t\)</span> is time (in seconds), then <span class="math inline">\(\omega\)</span> is <em>angular frequency</em> (in radians per seconds). If <span class="math inline">\(t\)</span> is distance (in meters), <span class="math inline">\(\omega\)</span> is spatial angular frequency (in radians per meter).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>I will be using the wavelet naming scheme from <a href="https://pywavelets.readthedocs.io/en/latest/ref/index.html">PyWavelets</a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><strong>L. P. René de Cotret</strong> and B. J. Siwick, <em>A general method for baseline-removal in ultrafast electron powder diffraction data using the dual-tree complex wavelet transform</em>, Struct. Dyn. <strong>4</strong> (2017) <a href="http://scitation.aip.org/content/aca/journal/sdy/4/4/10.1063/1.4972518">DOI:10.1063/1.4972518</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>M. R. Otto, <strong>L. P. René de Cotret</strong>, <em>et al</em>, <em>How optical excitation controls the structure and properties of vanadium dioxide</em>, PNAS (2018) <a href="https://doi.org/10.1073/pnas.1808414115">DOI: 10.1073/pnas.1808414115</a>.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Note that this distribution contains a bias of -<span class="math inline">\(1/2\)</span>, which is useful in order to introduce low-frequencies in the noise which overlap with the spectrum of the signal.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>N. G. Kingsbury, <em>The dual-tree complex wavelet transform: a new technique for shift invariance and directional filters</em>, IEEE Digital Signal Processing Workshop, DSP <strong>98</strong> (1998)<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
    <pubDate>Wed, 23 Nov 2022 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/wavelet-filtering.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>Chesterton's fence and why I'm not sold on the blockchain</title>
    <link>https://laurentrdc.xyz//posts/chesterton.html</link>
    <description><![CDATA[<p>The key technological advances which brought Bitcoin to life are the blockchain and its associated proof-of-work consensus algorithm. The Bitcoin whitepaper<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> is very clear on its purpose:</p>
<blockquote>
<p>A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending.</p>
</blockquote>
<p>The <em>double-spending</em> problem to which Nakamoto refers is a unique challenge of digital cash implementations. Contrary to physical cash, which is difficult to copy, digital cash is but bytes; it can be trivially copied. Before Bitcoin, the most popular way to prevent double-spending has been to route all digital cash transactions on a particular network through a trusted entity which ensures that no double-spending occurs. This is how the credit card and Interac networks work, for example.</p>
<p>The Bitcoin whitepaper brings a new solution to the double-spending problem, a solution designed to explicitly avoid centralized trusted entities.</p>
<hr />
<p>In software engineering, there is a principle that one should understand <em>why</em> something is the way it is, before trying to change it. This principle is known as <em>Chesterton’s fence</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
<blockquote>
<p>There exists (…) a fence or gate erected across a road. The more modern type of reformer goes gaily up to it and says, ‘I don’t see the use of this; let us clear it away.’ To which the more intelligent type of reformer will do well to answer: ’If you don’t see the use of it, I certainly won’t let you clear it away. Go away and think. Then, when you can come back and tell me that you do see the use of it, I may allow you to destroy it.</p>
</blockquote>
<p>To me, the push towards decentralization is a case of Chesterton’s fence. No one wants to involve a third-party in every transactions, but it is this way for two main reasons: fraud management and performance (transaction throughput).</p>
<p><strong>Fraud management</strong> is a weak point of an anonymous peer-to-peer network like Bitcoin. While I appreciate the desire for anonymity, this leads to the same behaviors which lead to the founding of the US Securities and Exchange Commission almost a hundred years ago. Decentralization also enabled the rise of ransomware, as it is now much harder to track the flow of money between anonymous, single-use cryptocurrency accounts.</p>
<p><strong>Performance</strong> is another major downside of decentralization. As an example, Bitcoin’s throughput has never reached more than <a href="https://blockchair.com/bitcoin/charts/transactions-per-second">6 transactions per second</a> as of the time of writing. By contract, the electronic payment network VisaNet (which powers Visa credit card) can process up to <a href="https://usa.visa.com/about-visa/visanet.html">76 000 transactions per second</a>.</p>
<p>Until blockchain enthusiasts understand the advantages of centralization presented above, I don’t think cryptocurrencies will become mainstream.</p>
<p><em>This post was inspired by the <a href="https://rationalreminder.ca/podcast/crypto8">Tim O’Reilly interview on the Rational Reminder podcast</a></em>.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>S. Nakamoto, <em>Bitcoin: A Peer-to-Peer Electronic Cash System</em> (2008). <a href="https://bitcoin.org/bitcoin.pdf">Link to PDF</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>G. K. Chesterton, <em>The Thing: Why I Am a Catholic</em>, chapter 4 (1929).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
    <pubDate>Tue, 02 Aug 2022 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/chesterton.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>Exploring the multiverse of possibilities all at once using monads</title>
    <link>https://laurentrdc.xyz//posts/multiverse.html</link>
    <description><![CDATA[<p>I’m working on a global optimization problem these days. Unlike local optimization problems, e.g. what you would solve using least-square minimization, global optimization inevitably involves exhaustively evaluating all <em>possible</em> solutions and choosing the best one. As you can imagine, global optimization is much more computationally-intensive than local optimization, due to the size of the set of potential solutions. Speeding up a global optimization problem involves reducing the set of possible solution to a minimum, based on the specifics of the problem.</p>
<p>In this post, I’ll show you how to <em>build</em> the minimal set of possible solutions to an optimization problem, instead of searching for solutions in a larger space. As we’ll see, only viable solutions are ever considered. This will be done by splitting the computations into multiple universes whenever a choice is presented to us, such that we traverse the multiverse of possibilities all at once.</p>
<h3 class="title is-3" id="an-example-problem">An example problem</h3>
<p>Let’s say we’ve got 8 friends going out for a drink, in two cars with four seats each. How many arrangements of people can we have? If we don’t care about where people sit in each car, the number of arrangements is the number of combinations of 4 people we can make from 8 people, since the remaining 4 people will go in the second car. For every configuration, there’s also a configuration which swaps the car. Therefore, there are:</p>
<p><span class="math display">\[
    \binom{8}{4} \times 2 = \frac{8!}{4!(8-4)!} \times 2 = 140
\]</span></p>
<p>possible combinations. If you’re not familiar with this notation, you can read <span class="math inline">\(\binom{8}{4}\)</span> as <em>choose 4 people out of 8 people</em>, of which there are 70 possibilities (and then 70 other possibilities with the cars swapped). That means that if we wanted to optimize the distribution of people into the two cars – for example, if we wanted to group up the best friends together, or minimize the total weight of people in car1, or some other objective –, we would need to look at 140 solutions. This problem is purely combinatorial.</p>
<p><em>Now let’s add some constraints</em>. Our 8 friends are coming back from the bar. Out of the 8 friends, 3 of them didn’t drink and are therefore allowed to drive. Thus, the number of possible arrangements of friends in the car has been reduced, as each car needs a driver. For one car, we need to select 1 driver out of 3, and 3 remaining passengers out of 7. However, the other car will need a driver, so really there are 6 passengers to choose from. Finally, for every arrangement there is a duplicate arrangement with the cars swapped. The number of possibilities is therefore:</p>
<p><span class="math display">\[
    \binom{3}{1} \binom{6}{3} \times 2 = 120
\]</span></p>
<h3 class="title is-3" id="potential-solutions-as-a-decision-graph">Potential solutions as a decision graph</h3>
<p>How else can we express the number of combinations? Think of building a solution, instead of searching for one. We may want to start by assigning a driver to car 1. For each possible decision here, we’ll assign a driver to the second car next, then passengers. The possibilities look like this:</p>
<figure class="python">
<img src="generated/pandocplot18224521120962782481.png" class="image" alt="Expressing the possibilities as a decision graph. Each layer represents a choice, and each trajectory from top to bottom represents a universe in which these choices were made. (Source code)" />
<figcaption aria-hidden="true">Expressing the possibilities as a decision graph. Each layer represents a choice, and each trajectory from top to bottom represents a universe in which these choices were made. (<a href="generated/pandocplot18224521120962782481.src.html">Source code</a>)</figcaption>
</figure>
<p>In the figure above, no one is assigned at the start. Then, we assign the first driver (out of three choices). Then, we need to assign a second driver, of which there are only two remaining. Each of the 6 passengers are then assigned. A potential solution (i.e. a assignment between people and cars) is represented by a path in the decision tree. Three possibilities are shown as examples.</p>
<p>This way of thinking about solutions reminds me strongly of the <a href="https://en.wikipedia.org/wiki/Many-worlds_interpretation">Everett interpretation of quantum mechanics</a>, also known as the <em>many-worlds interpretation</em> or the <em>multiverse interpretation</em>. The three potential assignments are three universes that split from the same starting point. Enumerating all possible solutions to our example problem consists in crawling the decision tree, or crawling the multiverse of possibilities.</p>
<h3 class="title is-3" id="expressing-the-multiverse-of-solutions-in-haskell">Expressing the multiverse of solutions in Haskell</h3>
<p>Based on the decision tree above, I want to run a computation which, when presented with choices, explores all possibilities all at once.</p>
<p>Consider the following type constructor:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Possibilities</span> a <span class="ot">=</span> <span class="dt">Possibilities</span> [a]</span></code></pre></div>
<p>A computation that returns a result <code>Possibilities a</code> represents all possible answers of final type <code>a</code>. For example, a computation can possibly have multiple answers might look like:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">possibly ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Possibilities</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>possibly xs <span class="ot">=</span> <span class="dt">Possibilities</span> xs</span></code></pre></div>
<p>Alternatively, a computation which is <em>certain</em>, i.e. has a single possibility, is represented by:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">certainly ::</span> a <span class="ot">-&gt;</span> <span class="dt">Possibilities</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>certainly x <span class="ot">=</span> <span class="dt">Possibilities</span> [x] <span class="co">-- A single possibility = a certainty.</span></span></code></pre></div>
<p><code>Possibilities</code> is basically a list, so we’ll start with a <code>Foldable</code> instance which is useful for counting the number of possibilities using <code>length</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Possibilities</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">foldMap</span> m (<span class="dt">Possibilities</span> xs) <span class="ot">=</span> <span class="fu">foldMap</span> m xs</span></code></pre></div>
<p><code>Possibilities</code> is a functor:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Possibilities</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Possibilities</span> ps) <span class="ot">=</span> <span class="dt">Possibilities</span> (<span class="fu">fmap</span> f ps)</span></code></pre></div>
<p>The interesting tidbit starts with the <code>Applicative</code> instance. Combining possibilities should be combinatorial, e.g. combining the possibilities of 3 drivers and 6 passengers results in 18 possibilities.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Possibilities</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> certainly x <span class="co">-- see above</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Possibilities</span> fs) <span class="op">&lt;*&gt;</span> (<span class="dt">Possibilities</span> ps) <span class="ot">=</span> <span class="dt">Possibilities</span> [f p <span class="op">|</span> f <span class="ot">&lt;-</span> fs, p <span class="ot">&lt;-</span> ps]</span></code></pre></div>
<p>Recall that the list comprehension notation is combinatorial, i.e. <code>[(n,m) | n &lt;- [1..3], m &lt;- [1..3]]</code> has 9 elements (<code>[(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]</code>).</p>
<p>Now for the crucial part of composing possibilities. We want past possibilities to influence future possibilities; we’ll need a monad instance. A monad instance means that if we start with multiple possibilities, and each possibility can results in multiple possibilities, the whole computation should produce multiple possibilities<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Possibilities</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Possibilities</span> ps <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Possibilities</span> <span class="op">$</span> <span class="fu">concat</span> [toList (f p) <span class="op">|</span> p <span class="ot">&lt;-</span> ps] <span class="co">-- concat :: [ [a] ] -&gt; [a]</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            toList (<span class="dt">Possibilities</span> xs) <span class="ot">=</span> xs</span></code></pre></div>
<p>Let’s define some helper datatypes and functions. We</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">{- </span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">With the following imports:</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">import           Data.Set    (Set, (\\))</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">import qualified Data.Set as Set </span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- | All possible people which can be assigned to cars</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">People</span> <span class="ot">=</span> <span class="dt">Driver1</span>    <span class="op">|</span> <span class="dt">Driver2</span>    <span class="op">|</span> <span class="dt">Driver3</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Passenger1</span> <span class="op">|</span> <span class="dt">Passenger2</span> <span class="op">|</span> <span class="dt">Passenger3</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">Passenger4</span> <span class="op">|</span> <span class="dt">Passenger5</span> <span class="op">|</span> <span class="dt">Passenger6</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Bounded</span>, <span class="dt">Eq</span>, <span class="dt">Enum</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- A car assignment consists in two cars, each with a driver, </span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- as well as passengers</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">CarAssignment</span> </span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">CarAssignment</span> {<span class="ot"> driver1        ::</span> <span class="dt">Person</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>                    ,<span class="ot"> driver2        ::</span> <span class="dt">Person</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>                    ,<span class="ot"> car1Passengers ::</span> <span class="dt">Set</span> <span class="dt">Person</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>                    ,<span class="ot"> car2Passengers ::</span> <span class="dt">Set</span> <span class="dt">Person</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>                    }</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="ot">allDrivers ::</span> <span class="dt">Set</span> <span class="dt">Person</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>allDrivers <span class="ot">=</span> Set.fromList [<span class="dt">Driver1</span>, <span class="dt">Driver2</span>, <span class="dt">Driver3</span>]</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pick a driver from an available group of people.</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- Returns the assigned driver, and the remaining unassigned people</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="ot">assignDriver ::</span> <span class="dt">Set</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Possibilities</span> (<span class="dt">Person</span>, <span class="dt">Set</span> <span class="dt">Person</span>)</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>assignDriver people </span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> possibly [ (driver, Set.delete driver people) </span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> driver <span class="ot">&lt;-</span> Set.toList <span class="op">$</span> people <span class="ot">`Set.intersection`</span> allDrivers</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>               ]</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pick three passengers from an available group of people.</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="co">-- Returns the assigned passengers, and the remaining unassigned people</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a><span class="ot">assign3Passengers ::</span> <span class="dt">Set</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Possibilities</span> (<span class="dt">Set</span> <span class="dt">Person</span>, <span class="dt">Set</span> <span class="dt">Person</span>)</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>assign3Passengers people <span class="ot">=</span> possibly [ (passengers, people \\ passengers) </span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>                                   <span class="op">|</span> passengers <span class="ot">&lt;-</span> setsOf3</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>                                   ]</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> setsOf3 <span class="ot">=</span> <span class="fu">filter</span> (\s <span class="ot">-&gt;</span> <span class="fu">length</span> s <span class="op">==</span> <span class="dv">3</span>) <span class="op">$</span> Set.toList <span class="op">$</span> Set.powerSet people</span></code></pre></div>
<p>Finally, we can express the multiverse of possible drivers-and-passengers assignments with great elegance. Behold:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">carAssignments ::</span> <span class="dt">Possibilities</span> <span class="dt">CarAssignment</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>carAssignments <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> everyone <span class="ot">=</span> Set.fromList <span class="op">$</span> <span class="fu">enumFromTo</span> <span class="fu">minBound</span> <span class="fu">maxBound</span> <span class="co">-- [Driver1, Driver2, ..., Passenger6]</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    (driver1, rest) <span class="ot">&lt;-</span> assignDriver everyone</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    (driver2, rest) <span class="ot">&lt;-</span> assignDriver rest</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    (car1Passengers, rest) <span class="ot">&lt;-</span> assign3Passengers rest</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    (car2Passengers, _)    <span class="ot">&lt;-</span> assign3Passengers rest</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="dt">CarAssignment</span> driver1 driver2 car1Passengers car2Passengers</span></code></pre></div>
<p>Given the monad instance for <code>Possibilities</code>, the <code>return</code> function returns all possible possibilities. Let’s take a look at the size of the multiverse in this case:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="kw">let</span> multiverse <span class="ot">=</span> carAssignments</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">print</span> <span class="op">$</span> <span class="fu">length</span> multiverse</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dv">120</span></span></code></pre></div>
<p>Just as we had calculated by hand. Amazing!</p>
<h3 class="title is-3" id="conclusion">Conclusion</h3>
<p>What I’ve shown you today is how to structure computations in such a way that you are exploring the multiverse of possibilities all at once. The seasoned Haskell programmer will have recognized that the <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> instances of <code>Possibilities</code> are just like lists!</p>
<p>Although I’m not using Haskell at work<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, I expect that something similar will need to be built in the near future to speed up our global optimization problem. The specific problem we are tackling has many more constraints than the example presented in this post. It’s easier to generate a list of solutions, most of which are unsuitable, and filter the solutions one by one. There is a fixed computational cost associated with generating and checking a solution, and so reducing the set of possible solutions is even more important.</p>
<p>This post was partly inspired by the legendary blog post <a href="https://aphyr.com/posts/342-typing-the-technical-interview">Typing the technical interview</a></p>
<p><em>A self-contained Haskell source file containing all code from this post is <a href="/files/multiverse.hs">available for download here</a></em></p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This is why some people like to thing of monads as types that support flatMap.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Boss, if you’re reading this, please let me use Haskell :).<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
    <pubDate>Wed, 02 Mar 2022 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/multiverse.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>Can you make heterogeneous lists in Haskell? Sure — as long as your intent is clear</title>
    <link>https://laurentrdc.xyz//posts/existential.html</link>
    <description><![CDATA[<p><em>Featured in <a href="https://haskellweekly.news/issue/283.html">Haskell Weekly issue 283</a></em></p>
<p>Sometimes, Haskell’s type system seems a bit restrictive compared to dynamic languages like Python. The most obvious example is the heterogenous list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="co"># Python</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> mylist <span class="op">=</span> [<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>, <span class="dv">117</span>, <span class="va">None</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="cf">for</span> item <span class="kw">in</span> mylist:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>...     <span class="bu">print</span>(item) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>hello</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>world</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">117</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="va">None</span></span></code></pre></div>
<p>but in Haskell, list items must be of the same type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Haskell</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>mylist <span class="ot">=</span> [<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>, <span class="dv">117</span>, ()] <span class="co">-- Invalid: type cannot be inferred!</span></span></code></pre></div>
<p>This is a contrived example, of course. But consider this use-case: I just want to print the content of the list. It’s unfortunate I can’t write:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mylist ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> [a]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>mylist <span class="ot">=</span>  [<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;world&quot;</span>, <span class="dv">117</span>, ()] <span class="co">-- All these types have Show instances, but this won&#39;t compile</span></span></code></pre></div>
<p>For this specific application, the type system is overly restrictive – as long as all I want to do is print the content of my list! In this post, I’ll show you how to do something like this using the <code>ExistentialQuantification</code> language extension.</p>
<h2 class="title is-2" id="a-more-complex-example">A more complex example</h2>
<p>Let’s say I want to list American football players. There are two broad classes of players (offensive and defensive) and we want to keep track of the players in a list – the player registry. Our final objective is to print the list of players to standard output.</p>
<p>Let’s try to do the same in Haskell. Our first reflex might be to use a sum type:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Player</span> <span class="ot">=</span> <span class="dt">OffensivePlayer</span> <span class="dt">String</span> <span class="dt">String</span> <span class="co">-- name and position</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">DefensivePlayer</span> <span class="dt">String</span> <span class="dt">String</span> <span class="co">-- name and position</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">playerRegistry ::</span> [<span class="dt">Player</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>playerRegistry <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>However, not all sports stats apply to <code>OffensivePlayer</code> and <code>DefensivePlayer</code> constructors. For example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">passingAccuracy ::</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>passingAccuracy (<span class="dt">OffensivePlayer</span> name pos) <span class="ot">=</span> lookupFromDatabase <span class="st">&quot;passingAccuracy&quot;</span> name</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>passingAccuracy (<span class="dt">DefensivePlayer</span> name pos) <span class="ot">=</span> <span class="fu">return</span> <span class="dv">0</span> <span class="co">-- Defensive players don&#39;t pass</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="ot">tacklesPerGame ::</span> <span class="dt">Player</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>tacklesPerGame (<span class="dt">OffensivePlayer</span> name pos) <span class="ot">=</span> <span class="fu">return</span> <span class="dv">0</span> <span class="co">-- Offensive players don&#39;t tackle</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>tacklesPerGame (<span class="dt">DefensivePlayer</span> name pos) <span class="ot">=</span> lookupFromDatabase <span class="st">&quot;tacklesPerGame&quot;</span> name</span></code></pre></div>
<p>The <code>Player</code> type is too general; we’re not using the type system to its full potential. It’s much more representative of our situation to use two separate types:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OffensivePlayer</span> <span class="ot">=</span> <span class="dt">OffensivePlayer</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DefensivePlayer</span> <span class="ot">=</span> <span class="dt">DefensivePlayer</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">passingAccuracy ::</span> <span class="dt">OffensivePlayer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>passingAccuracy <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="ot">tacklesPerGame ::</span> <span class="dt">DefensivePlayer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>tacklesPerGame <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>This is much safer and appropriate. Now let’s give ourselves the ability to print players:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">OffensivePlayer</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">OffensivePlayer</span> name pos) <span class="ot">=</span> <span class="fu">mconcat</span> [<span class="st">&quot;&lt; &quot;</span>, name, <span class="st">&quot; : &quot;</span>, pos, <span class="st">&quot; &gt;&quot;</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">DefensivePlayer</span> <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">DefensivePlayer</span> name pos) <span class="ot">=</span> <span class="fu">mconcat</span> [<span class="st">&quot;&lt; &quot;</span>, name, <span class="st">&quot; : &quot;</span>, pos, <span class="st">&quot; &gt;&quot;</span>]</span></code></pre></div>
<p>Awesome. One last problem:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- This won&#39;t typecheck</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>playerRegistry <span class="ot">=</span> [ <span class="dt">OffensivePlayer</span> <span class="st">&quot;Tom Brady&quot;</span>       <span class="st">&quot;Quarterback&quot;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                  , <span class="dt">DefensivePlayer</span> <span class="st">&quot;Michael Strahan&quot;</span> <span class="st">&quot;Defensive end&quot;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                  ]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">printPlayerList ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>printPlayerList <span class="ot">=</span> forM_ playerRegistry <span class="fu">print</span> <span class="co">-- `forM_` from Control.Monad</span></span></code></pre></div>
<p>Rather annoying. We could wrap the two player types in a sum type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Player</span> <span class="ot">=</span> <span class="dt">OP</span> <span class="dt">OffensivePlayer</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">DP</span> <span class="dt">DefensivePlayer</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Player</span> <span class="kw">where</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">OP</span> p) <span class="ot">=</span> <span class="fu">show</span> p</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">DP</span> p) <span class="ot">=</span> <span class="fu">show</span> p</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="ot">playerRegistry ::</span> [<span class="dt">Player</span>]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>playerRegistry <span class="ot">=</span> [ <span class="dt">OP</span> (<span class="dt">OffensivePlayer</span> <span class="st">&quot;Tom Brady&quot;</span>       <span class="st">&quot;Quarterback&quot;</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                 , <span class="dt">DP</span> (<span class="dt">DefensivePlayer</span> <span class="st">&quot;Michael Strahan&quot;</span> <span class="st">&quot;Defensive end&quot;</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                 ]</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="ot">printPlayerList ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>printPlayerList <span class="ot">=</span> forM_ playerRegistry <span class="fu">print</span>        </span></code></pre></div>
<p>but this is quite clunky. It also doesn’t scale well to cases where we have a lot more types!</p>
<h2 class="title is-2" id="enter-existential-quantification">Enter existential quantification</h2>
<p>The latest version of the Haskell language (Haskell 2010) is somewhat dated at this point. However, the Glasgow Haskell Compiler supports <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts.html">language extensions</a> at the cost of portability. Turns out that the <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/existential_quantification.html#existentially-quantified-data-constructors"><code>ExistentialQuantification</code></a> language extension can help us with this problem.</p>
<p>We turn on the extension at the top of our module:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></span></code></pre></div>
<p>and create an existential datatype:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ShowPlayer</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Show</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>                <span class="ot">=&gt;</span> <span class="dt">ShowPlayer</span> a</span></code></pre></div>
<p>The datatype <code>ShowPlayer</code> is a real datatype that bundles any data <code>a</code> which can be shown. Note that <strong>everything else</strong> about the internal type is forgotten, since the <code>ShowPlayer</code> type wraps <strong>any</strong> type that can be shown (that’s what <code>forall a. Show a</code> means).</p>
<p>We can facilitate the construction of a <code>Player</code> with the following helper function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkPlayer ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowPlayer</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>mkPlayer a <span class="ot">=</span> <span class="dt">ShowPlayer</span> a <span class="fu">show</span> </span></code></pre></div>
<p>Now since the data bundled in a <code>ShowPlayer</code> can be shown, the only operation supported by <code>ShowPlayer</code> is <code>Show</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">ShowPlayer</span> <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">ShowPlayer</span> a) <span class="ot">=</span> <span class="fu">show</span> a</span></code></pre></div>
<p>Finally, our heterogenous list:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">playerRegistry ::</span> [<span class="dt">ShowPlayer</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>playerRegistry <span class="ot">=</span> [ <span class="co">-- ✓ OffensivePlayer has a Show instance ✓</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                   <span class="dt">ShowPlayer</span> (<span class="dt">OffensivePlayer</span> <span class="st">&quot;Tom Brady&quot;</span>       <span class="st">&quot;Quarterback&quot;</span>))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>                   <span class="co">-- ✓ DefensivePlayer has a Show instance ✓</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                 , <span class="dt">ShowPlayer</span> (<span class="dt">DefensivePlayer</span> <span class="st">&quot;Michael Strahan&quot;</span> <span class="st">&quot;Defensive end&quot;</span>))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>                 ]</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="ot">printPlayerList ::</span> <span class="dt">IO</span> ()</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>printPlayerList <span class="ot">=</span> forM_ playerRegistry <span class="fu">print</span> </span></code></pre></div>
<p>So we <em>can</em> have an heterogenous list – as long as the only thing we can do with it is show it!</p>
<p>The advantage here compared to the sum-type approach is when we extend our code to many more types:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Quarterback</span>    <span class="ot">=</span> <span class="dt">Quarterback</span>  <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Lineman</span>        <span class="ot">=</span> <span class="dt">Lineman</span>      <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Runningback</span>    <span class="ot">=</span> <span class="dt">Runningback</span>  <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">WideReceiver</span>   <span class="ot">=</span> <span class="dt">WideReceiver</span> <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DefensiveEnd</span>   <span class="ot">=</span> <span class="dt">DefensiveEnd</span> <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Linebacker</span>     <span class="ot">=</span> <span class="dt">Linebacker</span>   <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Safety</span>         <span class="ot">=</span> <span class="dt">Safety</span>       <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Corner</span>         <span class="ot">=</span> <span class="dt">Corner</span>       <span class="dt">String</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Example: some functions are specific to certain positions</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="ot">passingAccuracy ::</span> <span class="dt">Quarterback</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>assingAccuracy <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="ot">playerRegistry ::</span> [<span class="dt">ShowPlayer</span>]</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>playerRegistry <span class="ot">=</span> [ mkPlayer (<span class="dt">Quarterback</span>  <span class="st">&quot;Tom Brady&quot;</span>))</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>                 , mkPlayer (<span class="dt">DefensiveEnd</span> <span class="st">&quot;Michael Strahan&quot;</span>))</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>                 , mkPlayer (<span class="dt">Safety</span>       <span class="st">&quot;Richard Sherman&quot;</span>))</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>                 , <span class="op">...</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>                 ]</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="ot">printPlayerList ::</span> <span class="dt">IO</span> ()</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>printPlayerList <span class="ot">=</span> forM_ playerRegistry <span class="fu">print</span> </span></code></pre></div>
<p>This way, we can keep the benefits of the type system when we want it, but also give ourselves some flexibility when we need it. This is actually similar to object-oriented programming, where classes bundle data and operations on them into an <strong>object</strong>!</p>
<h2 class="title is-2" id="a-bit-more-functionality">A bit more functionality</h2>
<p>Let’s pack in more operations on our heterogenous list. We might want to not only show players, but also access their salaries. We describe the functionality common to all players in a typeclass called <code>BasePlayer</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Show</span> p <span class="ot">=&gt;</span> <span class="dt">BasePlayer</span> p <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Operate in IO because of database access, for example</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    getYearlySalary ::</span> p <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BasePlayer</span> <span class="dt">Quarterback</span> <span class="kw">where</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BasePlayer</span> <span class="dt">Lineman</span> <span class="kw">where</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p>We can update our player registry to support the same operations as <code>BasePlayer</code> through the <code>Player</code> existential type:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Player</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">BasePlayer</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">=&gt;</span> <span class="dt">Player</span> a</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Player</span> <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">show</span> (<span class="dt">Player</span> a) <span class="ot">=</span> <span class="fu">show</span> a</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BasePlayer</span> <span class="dt">Player</span> <span class="kw">where</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    getYearlySalary (<span class="dt">Player</span> a) <span class="ot">=</span> getYearlySalary a</span></code></pre></div>
<p>and our new heterogenous list now supports:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">playerRegistry ::</span> [<span class="dt">Player</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>playerRegistry <span class="ot">=</span> [ <span class="dt">Player</span> (<span class="dt">Quarterback</span>  <span class="st">&quot;Tom Brady&quot;</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                 , <span class="dt">Player</span> (<span class="dt">DefensiveEnd</span> <span class="st">&quot;Michael Strahan&quot;</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                 , <span class="dt">Player</span> (<span class="dt">Safety</span>       <span class="st">&quot;Richard Sherman&quot;</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>                 , <span class="op">...</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                 ]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="ot">printPlayerList ::</span> <span class="dt">IO</span> ()</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>printPlayerList <span class="ot">=</span> forM_ playerRegistry <span class="fu">print</span> <span class="co">-- unchanged</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="ot">average_salary ::</span> <span class="dt">IO</span> <span class="dt">Double</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>average_salary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    salaries <span class="ot">&lt;-</span> for playerRegistry getYearlySalary <span class="co">-- (`for` from Data.Traversable)</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="fu">sum</span> salaries) <span class="op">/</span> (<span class="fu">length</span> salaries)</span></code></pre></div>
<p>So we can have a heterogenous list – but we can only perform operations which are supported by the <code>Player</code> type. In this sense, the <code>Player</code> type encodes our <em>intent</em>.</p>
<h2 class="title is-2" id="conclusion">Conclusion</h2>
<p>In this post, we’ve seen how to create heterogenous lists in Haskell. However, contrary to dynamic languages, we can only do so <em>provided we are explicit</em> about our intent. That means we get the safety of strong, static types with some added flexibility if we so choose.</p>
<p>If you’re interested in type-level programming, including but not limited to the content of this present post, I strongly recommend Rebecca Skinner’s <a href="https://rebeccaskinner.net/posts/2021-08-25-introduction-to-type-level-programming.html">An Introduction to Type Level Programming</a></p>
<p><em>Thanks to <a href="https://brandonchinn178.github.io/blog/">Brandon Chinn</a> for some explanation on how to simplify existential types</em>.</p>]]></description>
    <pubDate>Sun, 26 Sep 2021 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/existential.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>In defence of the PhD prelim exam</title>
    <link>https://laurentrdc.xyz//posts/prelim.html</link>
    <description><![CDATA[<p>In the <a href="http://www.physics.mcgill.ca">department of Physics</a> at McGill University, there are a few requirements for graduation in the PhD program. One of these requirements is to pass the <em>preliminary examination</em>, or prelim for short, at the end of the first year<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. This type of examination is becoming rarer across North America. The Physics department has been discussing the modernization of the prelim, either by changing its format or removing it entirely.</p>
<p>In this post, I want to explain what the prelim is and why I think its essence should be preserved.</p>
<h3 class="title is-3" id="what-is-the-prelim">What is the prelim?</h3>
<p>The prelim in its pre-COVID-19 form is a 6h sit-down exam, split in two 3h sessions. It aims to test students’ mastery of Physics concepts at the undergraduate level. At McGill, there are four themes of questions:</p>
<ol type="1">
<li>Classical mechanics and special relativity;</li>
<li>Thermodynamics and statistical mechanics;</li>
<li>Electromagnetism;</li>
<li>Quantum mechanics.</li>
</ol>
<p>The first 3h session is composed of 16 short questions, 10 of which must be answered. Some of the short questions are conceptual, while other involve a small calculations. Here is an example of a short question from the year I passed the prelim:</p>
<blockquote>
<p>Imagine a planet being a long infinite solid cylinder of radius <span class="math inline">\(R\)</span> with a mass per unit length <span class="math inline">\(\Lambda\)</span>. The matter is uniformly distributed over its radius. Find the potential and gravitational field everywhere, i.e. inside and outside the cylinder, and sketch the field lines.</p>
</blockquote>
<p>The second 3h session is composed of 8 long questions, split evenly among the four themes. Four questions must be answered (no more!), with at least one question from each theme. Here is an example of a long question from the year I passed the prelim:</p>
<blockquote>
<p>A simple 1-dimensional model for an ionic crystal (such as NaCl) consists of an array of <span class="math inline">\(N\)</span> point charges in a straight line, alternately <span class="math inline">\(+e\)</span> and <span class="math inline">\(−e\)</span> and each at a distance <span class="math inline">\(a\)</span> from its nearest neighbours. If <span class="math inline">\(N\)</span> is very large, find the potential energy of a charge in the middle of the row and of one at the end of the row in the form <span class="math inline">\(\alpha e^2/(4\pi \epsilon_0 a)\)</span>.</p>
</blockquote>
<p>I passed the prelim exam in 2018. For the curious, here are all the questions from that year: <a href="/files/prelim/prelim-short-2018.pdf">short (PDF)</a> and <a href="/files/prelim/prelim-long-2018.pdf">long (PDF)</a>. The department of Physics also keeps a <a href="http://www.physics.mcgill.ca/grads/prelim/">record of the prelim questions going back to 1996</a>. Senior undergraduates are well-equipped to answer prelim questions. The difficulty comes from the breath of possible questions, as well as the time constraint.</p>
<h3 class="title is-3" id="a-test-of-competence">A test of competence</h3>
<p>Of course, the prelim is only one of the requirements on the way to earn a doctoral degree. Most importantly, PhD students need to write a dissertation and defend its content in front of a committee of experts. So why have the prelim at all?</p>
<p>The prelim serves as a way to ensure that all PhD students have a certain level of competence in all historical areas of Physics. Evaluating students for admission to the Physics department is inherently hard because it is difficult to compare academic records from different institutions across the world.</p>
<p>Earning a PhD makes you an expert in a narrow subject. Passing the prelim indicates that students have a baseline knowledge across all historical Physics discipline.</p>
<h3 class="title is-3" id="proposed-alternative-the-comprehensive-examination">Proposed alternative: the comprehensive examination</h3>
<p>Not every department in the McGill Faculty of Science requires PhD students to pass a prelim exam. Another popular alternative, in use in the Chemistry department for example, is the so-called <em>comprehensive examination</em><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>The structure of the comprehensive exam varies across departments, but generally it involves the student writing a multi-page project proposal and defending this proposal in front of a committee of faculty members. In the course of the comprehensive exam, committee members may ask the student any question related to their research topic.</p>
<p>A comprehensive exam has two attractive attributes. First, its scope is closer to students’ area of research. Second, a large part of the comprehensive (the project proposal) can be done offline, without the pressure of being timed.</p>
<h3 class="title is-3" id="in-defence-of-the-prelim">In defence of the prelim</h3>
<p>The prelim is a stressful event. Not everyone is comfortable in a sit-down exam setting. A PhD career can end because someone slept poorly the night before the exam. I support any and all adjustments to the current prelim format to make the experience more accessible in this sense.</p>
<p>My main objection with replacing the prelim with something closer to the comprehensive exam is the <em>functionalization of education</em>. Removing the prelim eliminates the incentive to have a baseline knowledge across Physics. It encourages PhD students to have an even narrower set of skills, making the PhD program more focused around the resulting dissertation.</p>
<p>The comprehensive exam is inherently about making students’ experience more focused on their research area. This is appealing from students point-of-view: why should they have to go out of their way to stay aware about classical mechanics, something which they might never use? The comprehensive exam (in the format that I have described above) streamlines the requirements for graduation.</p>
<p>The graduate student experience is about much more than the resulting dissertation. We want our students to be more than just experts in their narrow fields; we also want them to be ready to contribute to society beyond their immediate expertise. Does the prelim ensure that this is the case? Of course not. But removing the prelim sends the wrong message about what it means to graduate with a PhD.</p>
<p>On a personal note, the prelim made me review all of my undergraduate studies. I purchased the Feynman Lectures on Physics and read all three volumes. With a Masters’ degree under my belt, I was able to appreciate my learnings under a new light, even though I haven’t used most of it since then. While I cannot say that the exam was fun, the studying experience was definitely one of the highlights of my PhD.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Other institutions might call it the qualifying examination.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Again, this might have other names at other institutions.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
    <pubDate>Sat, 12 Jun 2021 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/prelim.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>Harnessing symmetry to find the center of a diffraction pattern</title>
    <link>https://laurentrdc.xyz//posts/autocenter.html</link>
    <description><![CDATA[<p>Ultrafast electron diffraction involves the analysis of <em>diffraction patterns</em>. Here is an example diffraction pattern for a thin (&lt;100nm) flake of graphite<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<figure class="python">
<img src="generated/pandocplot3012530427581460854.png" class="image" alt="Diffraction pattern of graphite (Source code)" />
<figcaption aria-hidden="true">Diffraction pattern of graphite (<a href="generated/pandocplot3012530427581460854.src.html">Source code</a>)</figcaption>
</figure>
<p>A diffraction pattern is effectively the intensity of the Fourier transform. Given that crystals like graphite are well-ordered, the diffraction peaks (i.e. Fourier components) are very large. You can see that the diffraction pattern is six-fold symmetric; that’s because the atoms in graphite arrange themselves in a honeycomb pattern, which is also six-fold symmetric. In these experiments, the fundamental Fourier component is so strong that we need to block it. That’s what that black <em>beam-block</em> is about.</p>
<p>There are crystals that are not as well-ordered as graphite. Think of a powder made of many small crystallites, each being about 50nm x 50nm x 50nm. Diffraction electrons through a sample like that results in a kind of average of all possible diffraction patterns. Here’s an example with polycrystalline Chromium:</p>
<figure class="python">
<img src="generated/pandocplot14161707752663129345.png" class="image" alt="Diffraction pattern of polycrystalline Chromium (Source code)" />
<figcaption aria-hidden="true">Diffraction pattern of polycrystalline Chromium (<a href="generated/pandocplot14161707752663129345.src.html">Source code</a>)</figcaption>
</figure>
<p>Each ring in the above pattern pattern corresponds to a Fourier component. Notice again how symmetric the pattern is; the material itself is symmetric enough that the fundamental Fourier component needs to be blocked.</p>
<p>For my work on <a href="https://github.com/LaurentRDC/iris-ued">iris-ued</a>, a data analysis package for ultrafast electron scattering, I needed to find a reliable, automatic way to get the center of such diffraction patterns to get rid of the manual work required now. So let’s see how!</p>
<h2 class="title is-2" id="first-try-center-of-mass">First try: center of mass</h2>
<p>A first naive attempt might start with the <em>center-of-mass</em>, i.e. the average of pixel positions weighted by their intensity. Since intensity is symmetric about the center, the <em>center-of-mass</em> should coincide with the actual physical center of the image.</p>
<p>Good news, <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html#multidimensional-image-processing-scipy-ndimage">scipy’s <code>ndimage</code> module</a> exports such a function: <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.center_of_mass.html#scipy.ndimage.center_of_mass"><code>center_of_mass</code></a>. Let’s try it:</p>
<figure class="python">
<img src="generated/pandocplot4382677703533863771.png" class="image" alt="Demonstration of using scipy.ndimage.center_of_mass to find the center of diffraction patterns. (Source code)" />
<figcaption aria-hidden="true">Demonstration of using <code>scipy.ndimage.center_of_mass</code> to find the center of diffraction patterns. (<a href="generated/pandocplot4382677703533863771.src.html">Source code</a>)</figcaption>
</figure>
<p>Not bad! Especially in the first image, really not a bad first try. But I’m looking for something <em>pixel-perfect</em>. Intuitively, the beam-block in each image should mess with the calculation of the center of mass. Let’s define the following areas that we would like to ignore:</p>
<figure class="python">
<img src="generated/pandocplot5402504050944864374.png" class="image" alt="Areas that are bright are defined as being masked (Source code)" />
<figcaption aria-hidden="true">Areas that are bright are defined as being masked (<a href="generated/pandocplot5402504050944864374.src.html">Source code</a>)</figcaption>
</figure>
<p>Masks are generally defined as boolean arrays with True (or 1) where pixels are valid, and False (or 0) where pixels are invalid. Therefore, we should ignore the weight of masked pixels. <code>scipy.ndimage.center_of_mass</code> does not support this feature; we need an extension of <code>center_of_mass</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> center_of_mass_masked(im, mask):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    rr, cc <span class="op">=</span> np.indices(im.shape)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> im <span class="op">*</span> mask.astype(im.dtype)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> np.average(rr, weights<span class="op">=</span>weights)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> np.average(cc, weights<span class="op">=</span>weights)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> r, c</span></code></pre></div>
<p>This is effectively an average of the row and column coordinates (<code>rr</code> and <code>cc</code>) weighted by the image intensity. The trick here is that <code>mask.astype(im.dtype)</code> is 0 where pixels are “invalid”; therefore they don’t count in the average! Let’s look at the result:</p>
<figure class="python">
<img src="generated/pandocplot1954218757689397032.png" class="image" alt="Demonstration of using center_of_mass_masked (see above) to find the center of diffraction patterns. (Source code)" />
<figcaption aria-hidden="true">Demonstration of using <code>center_of_mass_masked</code> (see above) to find the center of diffraction patterns. (<a href="generated/pandocplot1954218757689397032.src.html">Source code</a>)</figcaption>
</figure>
<p>I’m not sure if it’s looking better, honestly. But at least we have an approximate center! That’s a good starting point that feeds in to the next step.</p>
<h2 class="title is-2" id="friedel-pairs-and-radial-inversion-symmetry">Friedel pairs and radial inversion symmetry</h2>
<p>In his thesis<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, which is now also <a href="https://www.springer.com/us/book/9783030548506?utm_campaign=3_pier05_buy_print&amp;utm_content=en_08082017&amp;utm_medium=referral&amp;utm_source=google_books#otherversion=9783030548513">a book</a>, Nelson Liu describes how he does it:</p>
<blockquote>
<p>A rough estimate of its position is obtained by calculating the ‘centre of intensity’ or intensity-weighted arithmetic mean of the position of &gt; 100 random points uniformly distributed over the masked image; this is used to match diffraction spots into Friedel pairs amongst those found earlier. By averaging the midpoint of the lines connecting these pairs of points, a more accurate position of the centre is obtained.</p>
</blockquote>
<p>Friedel pairs are peaks related by inversion through the center of the diffraction pattern. The existence of these pairs is guaranteed by crystal symmetry. For polycrystalline patterns, Friedel pairs are averaged into rings; rings are always inversion-symmetric about their centers. Here’s an example of two Friedel pairs:</p>
<figure class="python">
<img src="generated/pandocplot18253979055719347481.png" class="image" alt="Example of two Friedel pairs: white circles form pair 1, while red circles form pair 2. (Source code)" />
<figcaption aria-hidden="true">Example of two Friedel pairs: white circles form pair 1, while red circles form pair 2. (<a href="generated/pandocplot18253979055719347481.src.html">Source code</a>)</figcaption>
</figure>
<p>The algorithm by Liu was meant for single-crystal diffraction patterns with well-defined peaks, and not so much for rings. However, we can distill Liu’s idea into a new, more general approach. If the approximate center coincides with the actual center of the image, then the image should be invariant under radial-inversion with respect to the approximate center. Said another way: if the image <span class="math inline">\(I\)</span> is defined on polar coordinates <span class="math inline">\((r, \theta)\)</span>, then the center maximizes correlation between <span class="math inline">\(I(r, \theta)\)</span> and <span class="math inline">\(I(-r, \theta)\)</span>. Thankfully, computing the masked correlation between images <a href="/posts/mnxc.html">is something I’ve worked on before</a>!</p>
<p>Let’s look at what radial inversion looks like. There are ways to do it with interpolation, e.g. <a href="https://scikit-image.org/docs/stable/api/skimage.transform.html#warp">scikit-image’s <code>warp</code> function</a>. However, in my testing, this is incredibly slow compared to what I will show you. A faster approach is to consider that if the image was centered on the array, then radial inversion is really flipping the direction of the array axes; that is, if the image array <code>I</code> has size (128, 128), and the center is at (64, 64), the radial inverse of <code>I</code> is <code>I[::-1, ::-1]</code> (numpy) / <code>flip(flip(I, 1), 2)</code> (MATLAB) / <code>I[end:-1:1,end:-1:1]</code> (Julia). Another important note is that if the approximate center of the image is far from the center of the array, the overlap between the image and its radial inverse is limited. Consider this:</p>
<figure class="python">
<img src="generated/pandocplot17593316938677013141.png" class="image" alt=" (Source code)" />
<figcaption aria-hidden="true"> (<a href="generated/pandocplot17593316938677013141.src.html">Source code</a>)</figcaption>
</figure>
<p>If we cropped out the bright areas around the frame, then the approximate center found would coincide with the center of the array; then, radial inversion is very fast.</p>
<figure class="python">
<img src="generated/pandocplot11362520944862135144.png" class="image" alt="Demonstration of what parts of the image to crop so that the image center coincides with the center of the array. (Source code)" />
<figcaption aria-hidden="true">Demonstration of what parts of the image to crop so that the image center coincides with the center of the array. (<a href="generated/pandocplot11362520944862135144.src.html">Source code</a>)</figcaption>
</figure>
<p>Now, especially for the right column of images, it’s pretty clear that the approximate center wasn’t perfect. The <em>correction</em> to the approximate center is can be calculated with the masked normalized cross-correlation<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>:</p>
<figure class="python">
<img src="generated/pandocplot244423791329530845.png" class="image" alt="Top left: diffraction pattern. Top right: radially-inverted diffraction pattern about an approximate center. Bottom left: masked normalized cross-correlation between the two diffraction patterns. Bottom right: 2x zoom on the cross-correlation shows the translation mismatch between the diffraction patterns. (Source code)" />
<figcaption aria-hidden="true"><strong>Top left</strong>: diffraction pattern. <strong>Top right</strong>: radially-inverted diffraction pattern about an approximate center. <strong>Bottom left</strong>: masked normalized cross-correlation between the two diffraction patterns. <strong>Bottom right</strong>: 2x zoom on the cross-correlation shows the translation mismatch between the diffraction patterns. (<a href="generated/pandocplot244423791329530845.src.html">Source code</a>)</figcaption>
</figure>
<p>The cross-correlation in the bottom right corner (zoomed by 2x) shows that the true center is the approximate center we found earlier, corrected by the small shift (white arrow)! For single-crystal diffraction patterns, the resulting is even more striking:</p>
<figure class="python">
<img src="generated/pandocplot9330261641525732696.png" class="image" alt="Top left: diffraction pattern. Top right: radially-inverted diffraction pattern about an approximate center. Bottom left: masked normalized cross-correlation between the two diffraction patterns. Bottom right: 2x zoom on the cross-correlation shows the translation mismatch between the diffraction patterns. (Source code)" />
<figcaption aria-hidden="true"><strong>Top left</strong>: diffraction pattern. <strong>Top right</strong>: radially-inverted diffraction pattern about an approximate center. <strong>Bottom left</strong>: masked normalized cross-correlation between the two diffraction patterns. <strong>Bottom right</strong>: 2x zoom on the cross-correlation shows the translation mismatch between the diffraction patterns. (<a href="generated/pandocplot9330261641525732696.src.html">Source code</a>)</figcaption>
</figure>
<p>We can put the two steps together and determine a pixel-perfect center:</p>
<figure class="python">
<img src="generated/pandocplot1260332358214592272.png" class="image" alt=" (Source code)" />
<figcaption aria-hidden="true"> (<a href="generated/pandocplot1260332358214592272.src.html">Source code</a>)</figcaption>
</figure>
<h2 class="title is-2" id="bonus-low-quality-diffraction">Bonus: low-quality diffraction</h2>
<p>Here’s a fun consequence: the technique works also for diffraction patterns that are pretty crappy and very far off center, provided that the asymmetry in the background is taken care-of:</p>
<figure class="python">
<img src="generated/pandocplot7022146531103843802.png" class="image" alt=" (Source code)" />
<figcaption aria-hidden="true"> (<a href="generated/pandocplot7022146531103843802.src.html">Source code</a>)</figcaption>
</figure>
<h2 class="title is-2" id="conclusion">Conclusion</h2>
<p>In this post, we have determined a robust way to compute the center of a diffraction pattern without any parameters, by making use of a strong invariant: radial inversion symmetry. My favourite part: this method admits no free parameters!</p>
<p>If you want to make use of this, <a href="https://scikit-ued.readthedocs.io/en/master/functions/skued.autocenter.html#skued.autocenter">take a look at <code>autocenter</code></a>, a new function that has been added to <a href="https://github.com/LaurentRDC/scikit-ued">scikit-ued</a>.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>L.P. René de Cotret <em>et al</em>, <em>Time- and momentum-resolved phonon population dynamics with ultrafast electron diffuse scattering</em>, Phys. Rev. B <strong>100</strong> (2019) <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.100.214115">DOI: 10.1103/PhysRevB.100.214115</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Liu, Lai Chung. <a href="http://hdl.handle.net/1807/97517">Chemistry in Action: Making Molecular Movies with Ultrafast Electron Diffraction and Data Science</a>. University of Toronto, 2019.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Dirk Padfield. <em>Masked object registration in the Fourier domain</em>. IEEE Transactions on Image Processing, <strong>21</strong>(5):2706–2718, 2012. <a href="https://doi.org/10.1109/TIP.2011.2181402">DOI: 10.1109/TIP.2011.2181402</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Dirk Padfield. <em>Masked FFT registration</em>. Prov. Computer Vision and Pattern Recognition. pp 2918-2925 (2010). <a href="https://doi.org/10.1109/CVPR.2010.5540032">DOI:10.1109/CVPR.2010.5540032</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
    <pubDate>Sat, 23 Jan 2021 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/autocenter.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>Matplotlib for graphic design</title>
    <link>https://laurentrdc.xyz//posts/banner.html</link>
    <description><![CDATA[<p>In this post, I will show you how I generated the banner for this website using <a href="https://matplotlib.org/">Matplotlib</a>. In case it disappears in the future, here is an image of it:</p>
<figure class="python">
<img src="generated/pandocplot11701062483453091969.png" class="image" />
</figure>
<p>Matplotlib is a plotting library for python, historically inspired by the plotting capabilities of MATLAB. You can take a look at the various <a href="https://matplotlib.org/gallery/index.html">examples</a> on their website. One thing that is not immediately obvious is that you can use Matplotlib to also draw shapes! In this sense, Matplotlib becomes a graphic design library.</p>
<p>(You can see the exact source code for the images below by clicking on the link in the caption)</p>
<h3 class="title is-3" id="basic-shapes">Basic shapes</h3>
<p>Let’s start at the beginning: drawing a single hexagon.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.patches <span class="im">as</span> patches</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> draw_hexagon(ax, center, radius, color<span class="op">=</span><span class="st">&quot;w&quot;</span>):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    ax.add_patch(</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        mpatches.RegularPolygon(</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            xy<span class="op">=</span>center,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            numVertices<span class="op">=</span><span class="dv">6</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            radius<span class="op">=</span>radius,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            facecolor<span class="op">=</span>color,</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            edgecolor<span class="op">=</span><span class="st">&quot;k&quot;</span>,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            orientation<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            fill<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<p>Using the function, we can draw a tiling of hexagons. Let’s first set-up our plot:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Note that Matplotlib figure size is (width, height) in INCHES...</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># We want it to be 100mm x 100mm</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>mm_to_in <span class="op">=</span> <span class="fl">0.03937008</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>figure, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>,<span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">100</span> <span class="op">*</span> mm_to_in, <span class="dv">100</span><span class="op">*</span>mm_to_in))</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Hide as much of the axis borders/margins as possible</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>ax.axis(<span class="st">&quot;off&quot;</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(top<span class="op">=</span><span class="dv">1</span>, bottom<span class="op">=</span><span class="dv">0</span>, left<span class="op">=</span><span class="dv">0</span>, right<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>ax.set_xlim([<span class="dv">0</span>, <span class="dv">100</span>])</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>ax.set_ylim([<span class="dv">0</span>, <span class="dv">100</span>])</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Hexagon radius in mm</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>radius <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Dimensions of the bounding box of the hexagons</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> math.sqrt(<span class="dv">3</span>) <span class="op">*</span> radius</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>height <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> radius</span></code></pre></div>
<h3 class="title is-3" id="tiling">Tiling</h3>
<p>We note that a tiling of <em>regular</em> hexagons requires a different offset for every row. If you imagine rows being numbered starting at 0, hexagons in rows with odd indices need to be offset by <span class="math inline">\(\frac{\sqrt{3}}{2} r\)</span>, where <span class="math inline">\(r\)</span> is the radius (or distance from the center to vertex). To find the centers of the hexagons, the following loop does the trick:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>centers <span class="op">=</span> <span class="bu">list</span>()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> offset_x, offset_y <span class="kw">in</span> [(<span class="dv">0</span>, <span class="dv">0</span>), (width <span class="op">/</span> <span class="dv">2</span>, (<span class="dv">3</span> <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> radius)]:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    rows    <span class="op">=</span> np.arange(start<span class="op">=</span>offset_x, stop<span class="op">=</span><span class="dv">105</span>, step<span class="op">=</span>width)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    columns <span class="op">=</span> np.arange(start<span class="op">=</span>offset_y, stop<span class="op">=</span><span class="dv">105</span>, step<span class="op">=</span><span class="dv">3</span> <span class="op">*</span> radius)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y <span class="kw">in</span> itertools.product(rows, columns):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        centers.append( (x,y) )</span></code></pre></div>
<p>Once we know about the centers of the hexagons, we can place them one-by-one:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (x,y) <span class="kw">in</span> centers:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    draw_hexagon(ax, center<span class="op">=</span>(x,y), radius<span class="op">=</span>radius)</span></code></pre></div>
<p>Here’s what it looks like so far:</p>
<figure class="python">
<img src="generated/pandocplot17276650817721750394.png" class="image" alt=" (Source code)" />
<figcaption aria-hidden="true"> (<a href="generated/pandocplot17276650817721750394.src.html">Source code</a>)</figcaption>
</figure>
<h3 class="title is-3" id="color">Color</h3>
<p>The figure above has the wrong dimension, but you get the idea. Let’s color the hexagons appropriately. In the banner, the color of the hexagons is based on the <a href="https://matplotlib.org/tutorials/colors/colormaps.html">“inferno” colormap</a>. The color radiates away from the bottom left corner:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> draw_hexagon(ax, center, radius, color<span class="op">=</span><span class="st">&#39;w&#39;</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    ax.add_patch(</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        mpatches.RegularPolygon(</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>            xy<span class="op">=</span>center,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            numVertices<span class="op">=</span><span class="dv">6</span>,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>            radius<span class="op">=</span>radius,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            facecolor<span class="op">=</span>color,</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            edgecolor<span class="op">=</span><span class="st">&quot;none&quot;</span>, <span class="co">#note: edgecolor=None is actually the default value!</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            orientation<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            fill<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>colormap <span class="op">=</span> plt.get_cmap(<span class="st">&#39;inferno&#39;</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (x,y) <span class="kw">in</span> centers:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># radius away from bottom left corner</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># proportional to the distance of the top right corner</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># i.e. 0 &lt; r &lt; 1</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> math.hypot(x, y) <span class="op">/</span> math.hypot(<span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    draw_hexagon(ax, center<span class="op">=</span>(x, y), radius<span class="op">=</span>radius, color<span class="op">=</span>colormap(r))</span></code></pre></div>
<p>Here’s the result:</p>
<figure class="python">
<img src="generated/pandocplot87656670273778394.png" class="image" alt=" (Source code)" />
<figcaption aria-hidden="true"> (<a href="generated/pandocplot87656670273778394.src.html">Source code</a>)</figcaption>
</figure>
<p>Because of rounding errors of the hexagon dimensions, there is some visible spacing between the hexagons. To get rid of it, we draw the hexagons a bit larger (0.2 millimeters):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> draw_hexagon(ax, center, radius, color<span class="op">=</span><span class="st">&#39;w&#39;</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    ax.add_patch(</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        mpatches.RegularPolygon(</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>            xy<span class="op">=</span>center,</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>            numVertices<span class="op">=</span><span class="dv">6</span>,</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            radius<span class="op">=</span>radius <span class="op">+</span> <span class="fl">0.2</span>,</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            facecolor<span class="op">=</span>color,</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            edgecolor<span class="op">=</span><span class="st">&quot;none&quot;</span>,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            orientation<span class="op">=</span><span class="dv">0</span>,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            fill<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<h3 class="title is-3" id="a-bit-of-randomness">A bit of randomness</h3>
<p>For a light touch of whimsy, I like to make the color fluctuate a little:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>colormap <span class="op">=</span> plt.get_cmap(<span class="st">&#39;inferno&#39;</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (x,y) <span class="kw">in</span> centers:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># radius away from bottom left corner</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># proportional to the distance of the top right corner</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># i.e. 0 &lt; r &lt; 1</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> math.hypot(x, y) <span class="op">/</span> math.hypot(<span class="dv">100</span>, <span class="dv">100</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    r <span class="op">+=</span> random.gauss(<span class="dv">0</span>, <span class="fl">0.01</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    draw_hexagon(ax, center<span class="op">=</span>(x, y), radius<span class="op">=</span>radius, color<span class="op">=</span>colormap(r))</span></code></pre></div>
<p>We arrive at the final result:</p>
<figure class="python">
<img src="generated/pandocplot11239578649724822038.png" class="image" alt=" (Source code)" />
<figcaption aria-hidden="true"> (<a href="generated/pandocplot11239578649724822038.src.html">Source code</a>)</figcaption>
</figure>
<p>You can imagine adapting this approach to different tilings, and different colors schemes. Here’s a final example using squares and the <a href="https://matplotlib.org/tutorials/colors/colormaps.html">“cool” colormap</a>:</p>
<figure class="python">
<img src="generated/pandocplot13873111378649624085.png" class="image" alt=" (Source code)" />
<figcaption aria-hidden="true"> (<a href="generated/pandocplot13873111378649624085.src.html">Source code</a>)</figcaption>
</figure>]]></description>
    <pubDate>Tue, 03 Nov 2020 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/banner.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>The masked normalized cross-correlation and its application to image registration</title>
    <link>https://laurentrdc.xyz//posts/mnxc.html</link>
    <description><![CDATA[<p>Image registration consists in determinining the most likely transformation between two images — most importantly translation, which is what I am most concerned with.</p>
<p>How can we detect the translation between two otherwise similar image? This is an application of <strong>cross-correlation</strong>. The cross-correlation of two images is the degree of similitude between images for every possible translation between them. Mathematically, given grayscale images as discrete functions <span class="math inline">\(I_1(i,j)\)</span> and <span class="math inline">\(I_2(i,j)\)</span>, their cross-correlation <span class="math inline">\(I_1 \star I_2\)</span> is defined as:
<span class="math display">\[
    (I_1 \star I_2)(u, v) \equiv \sum_{i,j} I_1(i, j) \cdot I_2(i - u, j - v)
\]</span></p>
<p>For example, if <span class="math inline">\(I_1 = I_2\)</span>, then <span class="math inline">\(I_1 \star I_2\)</span> has its maximum at <span class="math inline">\((u,v) =\)</span> (0,0). What happens if <span class="math inline">\(I_1\)</span> and <span class="math inline">\(I_2\)</span> are shifted from each other? Let’s see:</p>
<figure class="python">
<img src="generated/pandocplot15499111724966621276.png" class="image" alt="The cross-correlation between shifted images exhibits a global maxima at the location corresponding to relative translation. (Source code)" />
<figcaption aria-hidden="true">The cross-correlation between shifted images exhibits a global maxima at the location corresponding to relative translation. (<a href="generated/pandocplot15499111724966621276.src.html">Source code</a>)</figcaption>
</figure>
<p>In the above example, the cross-correlation is maximal at (50, 0), which is exactly the translation required to <em>shift back</em> the second image to match the first one. Finding the translation between images is then a simple matter of determining the glocal maximum of the cross-correlation. This operation is so useful that it is implemented in the Python library <a href="https://scikit-image.org">scikit-image</a> as <a href="https://scikit-image.org/docs/dev/api/skimage.registration.html?highlight=phase#skimage.registration.phase_cross_correlation"><code>skimage.feature.phase_cross_correlation</code></a>.</p>
<p>It turns out that in my field of research, image registration can be crucial to correct experimental data. My primary research tool is <a href="http://www.physics.mcgill.ca/siwicklab">ultrafast electron diffraction</a>. Without knowing the details, you can think of this technique as a kind of microscope. A single image from one of our experiments looks like this:</p>
<figure>
<img src="/images/mnxc/Cr_1.png" class="image" alt="An electron diffraction pattern of polycrystalline chromium." />
<figcaption aria-hidden="true">An electron diffraction pattern of polycrystalline chromium.</figcaption>
</figure>
<p>Most of the electron beam is unperturbed by the sample; this is why we use a metal beam-block (seen as a black rod in the image above) to prevent the electrons from damaging our apparatus.</p>
<p>Our experiments are synthesized from hundreds of gigabytes of images like the one above, and it may take up to 72h (!) to take all the images we need. Over the course of this time, the electron beam may shift in a way that moves the image, but <em>not the beam-block</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Heres’s what I mean:</p>
<figure class="python">
<img src="generated/pandocplot12959182197921854250.png" class="image" alt="Here is the difference between two equivalent images, acquired a few hours apart. The shift between them is evident in the third panel. (Source code)" />
<figcaption aria-hidden="true">Here is the difference between two equivalent images, acquired a few hours apart. The shift between them is evident in the third panel. (<a href="generated/pandocplot12959182197921854250.src.html">Source code</a>)</figcaption>
</figure>
<p>This does not fly. We need to be able to compare images together, and shifts by more than 1px are problematic. We need to correct for this shift, for every image, with respect to the first one. However, we are also in a bind, because unlike the example above, the images are not completely shifted; one part of them, the beam-block, is <em>static</em>, while the image behind it shifts.</p>
<p>The crux of the problem is this: the cross-correlation between images gives us the shift between them. However, it is not immediately obvious how to tell the cross-correlation operation to ignore <em>certain parts</em> of the image. Is there some kind of operation, similar to the cross-correlation, that allows to mask parts of the images we want to ignore?</p>
<p>Thanks to the work of Dr. Dirk Padfield<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, we now know that such an operation exists: the <strong>masked normalized cross-correlation</strong>. <a href="https://doi.org/10.1109/TIP.2011.2181402">In his 2012 article</a>, he explains the procedure and performance of this method to register images with masks. One such example is the registration of ultrasound images; <a href="/images/mnxc/criminal.png">unfortunately, showing you the figure from the article would cost me 450 $US</a>, so you’ll have to go look at it yourselves.</p>
<hr>
<p>In order to fix our registration problem, then, I implemented the masked normalized cross-correlation operation — and its associated registration function — in our ultrafast electron diffraction toolkit, <a href="https://scikit-ued.rtfd.io">scikit-ued</a><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Here’s an example of it in action:</p>
<figure class="python">
<img src="generated/pandocplot17947095758610589515.png" class="image" alt="Using the masked-normalized cross-correlation to align two diffraction patterns of polycrystalline chromium. The mask shown tells the algorithm to ignore the beam-block of both images. (Source code)" />
<figcaption aria-hidden="true">Using the masked-normalized cross-correlation to align two diffraction patterns of polycrystalline chromium. The mask shown tells the algorithm to ignore the beam-block of both images. (<a href="generated/pandocplot17947095758610589515.src.html">Source code</a>)</figcaption>
</figure>
<h2 class="title is-2" id="contributing-to-scikit-image">Contributing to scikit-image</h2>
<p>However, since this tool could see use in a more general setting, I decided to contribute it to <a href="https://scikit-image.org/">scikit-image</a>:</p>
<ol type="1">
<li>My contribution starts by bringing up the subject via a GitHub issue (<a href="https://github.com/scikit-image/scikit-image/issues/3330">issue #3330</a>).</li>
<li>I forked scikit-image and integrated the code and tests from scikit-ued to scikit-image. The changes are visible in the <a href="https://github.com/scikit-image/scikit-image/pull/3334">pull request #3334</a>.</li>
<li>Finally, some documentation improvements and an additional gallery example were added in <a href="https://github.com/scikit-image/scikit-image/pull/3528">pull request #3528</a>.</li>
</ol>
<p>In the end, <strong>a new function has been added, <a href="https://scikit-image.org/docs/stable/api/skimage.registration.html#skimage.registration.phase_cross_correlation"><code>skimage.registration.phase_cross_correlation</code></a></strong> (previously <code>skimage.feature.masked_register_translation</code>).</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Technically, the rotation of the electron beam about its source will also move the shadow of the beam-block. However, because the beam-block is much closer to the electron source, the effect is imperceptible.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Dirk Padfield. <em>Masked object registration in the Fourier domain</em>. IEEE Transactions on Image Processing, <strong>21</strong>(5):2706–2718, 2012. <a href="https://doi.org/10.1109/TIP.2011.2181402">DOI: 10.1109/TIP.2011.2181402</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Dirk Padfield. <em>Masked FFT registration</em>. Prov. Computer Vision and Pattern Recognition. pp 2918-2925 (2010). <a href="https://doi.org/10.1109/CVPR.2010.5540032">DOI:10.1109/CVPR.2010.5540032</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>L. P. René de Cotret et al, <em>An open-source software ecosystem for the interactive exploration of ultrafast electron scattering data</em>, Advanced Structural and Chemical Imaging <strong>4</strong>:11 (2018) <a href="https://ascimaging.springeropen.com/articles/10.1186/s40679-018-0060-y">DOI:10.1186/s40679-018-0060-y</a>. This publication is open-access<i class="ai ai-open-access"></i> .<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
    <pubDate>Tue, 30 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/mnxc.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>
<item>
    <title>When one temperature is not enough: the two-temperature model</title>
    <link>https://laurentrdc.xyz//posts/two-temp-model.html</link>
    <description><![CDATA[<p>Temperature is a measure of the average kinetic energy of all particles in a system. An example of such as system is presented below:</p>
<figure>
<img src="/images/Translational_motion.gif" class="image" alt="Translational motion of particles in a box. Some particles are colored red for better tracking. Image credit to A. Greg." />
<figcaption aria-hidden="true">Translational motion of particles in a box. Some particles are colored red for better tracking. <a href="https://en.wikipedia.org/wiki/Thermodynamic_temperature#/media/File:Translational_motion.gif">Image credit to A. Greg.</a></figcaption>
</figure>
<p>Note that the above system has a temperature because there exists a clear <strong>average</strong> motion, even though not all particles are moving at the same velocity. This means, a system is at some temperature <span class="math inline">\(T\)</span> as long as the distribution of kinetic energies (often related to velocities) ressembles a <strong>normal distribution</strong>:</p>
<figure>
<img src="generated/pandocplot9724477912210193046.png" class="image" alt="Examples of distribution of particle kinetic energies. Left: distribution of particle energies with a well-defined temperature. Right: distribution of particle energies does not match an expected thermal equilibrium. (Source code)" />
<figcaption aria-hidden="true">Examples of distribution of particle kinetic energies. <strong>Left</strong>: distribution of particle energies with a well-defined temperature. <strong>Right</strong>: distribution of particle energies does not match an expected thermal equilibrium. (<a href="generated/pandocplot9724477912210193046.src.html">Source code</a>)</figcaption>
</figure>
<p>So, a system with a well-defined temperature exhibits a normal distribution of particle energies. It turns out that it is possible to prepare systems into a state where there are <em>two clear average energies</em> , if only for a very short moment.</p>
<p>Real materials are composed of two types of particles, nuclei and electrons<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. These particles have widly different masses, so electromagnetic fields — for example, an intense pulse of light — will not affect them at the same time; since nuclei are at least ~1000x more massive than electrons, we should expect the electrons to react about ~1000x faster.</p>
<p>After decades of development culminating in the 2018 Nobel Prize in Physics, the production of ultrafast laser pulses (less than 30 femtoseconds<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>) is now routine. These ultrafast laser pulses can be used to prepare systems in a strange configuration: one with seemingly <em>two temperatures</em>, albeit only for a short time. Modeling of this situation in crystalline material was done decades ago, and the model is known as the <strong>two-temperature model</strong><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.</p>
<p>Roughly 100fs after dumping a lot of energy into a material, the nuclei might not have reacted yet, and we might have the following energetic landscape:</p>
<figure>
<img src="generated/pandocplot9349399064228391331.png" class="image" alt="Idealized view of the distribution of kinetic energy, 100 femtosecond after photoexcitation by an ultrafast laser pulse. For a very short time, the system can be described by two temperatures; one for the lattice of nuclei, T_l, and one for the electronic system, T_e. (Source code)" />
<figcaption aria-hidden="true">Idealized view of the distribution of kinetic energy, 100 femtosecond after photoexcitation by an ultrafast laser pulse. For a very short time, the system can be described by two temperatures; one for the lattice of nuclei, <span class="math inline">\(T_l\)</span>, and one for the electronic system, <span class="math inline">\(T_e\)</span>. (<a href="generated/pandocplot9349399064228391331.src.html">Source code</a>)</figcaption>
</figure>
<p>where the nucliei will still be at equilibrium temperature, and the electrons might be at a temperature of 20000<span class="math inline">\(^{\circ}\)</span>C. Therefore, <em>we have a system with two temperatures</em> for a few picoseconds<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>The atomic forces at the nanometer-scale are mostly electromagnetic, so I will consider the atomic nuclei as a single particle.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><span class="math inline">\(1\)</span> femtosecond <span class="math inline">\(= 10^{-15}\)</span> seconds<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>P. B. Allen, <em>Theory of thermal relaxation of electrons in metals</em> (1987). Physics Review Letters <strong>59</strong>, DOI: <a href="https://link.aps.org/doi/10.1103/PhysRevLett.59.1460">10.1103/PhysRevLett.59.1460</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><span class="math inline">\(1\)</span> picosecond <span class="math inline">\(= 1000\)</span> fs <span class="math inline">\(= 10^{-12}\)</span> seconds<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
    <pubDate>Wed, 03 Apr 2019 00:00:00 UT</pubDate>
    <guid>https://laurentrdc.xyz//posts/two-temp-model.html</guid>
    <dc:creator>Laurent P. René de Cotret</dc:creator>
</item>

    </channel>
</rss>
